parameter int ;
storage (map int int) ;
code {
       # verify balance is sufficient to run contract
       AMOUNT ;
       PUSH mutez 5000000 ;
       COMPARE ; GT ;
       IF { FAIL } { } ;

       # get the storage (map) and parameter (string key)
       DUP ; DIP { CDR ; DUP } ; CAR ; DUP ;

       # lookup map[key] and return Some (map[key] + 1)
       DIP { GET ; ASSERT_SOME ;
             PUSH int 1 ; ADD ; SOME } ;

       # assign map[key] := map[key] + 1
       UPDATE ;

       # update map in storage
       NIL operation; PAIR
     } ;

amount 5000001 ;

input  { Stack_elt (pair int              (map int int)) $I } ;
output { Stack_elt (pair (list operation) (map int int)) $O } ;

precondition  { { PUSH (pair int (map int int)) $I ; UNPAIR ; MEM } } ;
postcondition { { PUSH (pair int (map int int)) $I                            # (S,M)
                ; CDR                                                         # M
                ; PUSH int $K                                                 # K M
                ; GET                                                         # M[K]?
                ; IF_NONE { PUSH bool True } {                                # M[K]
                    PUSH (pair (list operation) (map int int)) $O             # (O,M') M[K]
                  ; CDR                                                       # M' M[K]
                  ; PUSH int $K                                               # K M' M[K]
                  ; GET                                                       # M'[K]? M[K]
                  ; IF_NONE { UNIT ; FAILWITH } { }                           # M'[K]  M[K]
                  ; SWAP                                                      # M'[K]  M[K]

                  ; PUSH int $K                                               # K  M[K]  M'[K]
                  ; PUSH (pair int (map int int)) $I                          # (M,S)  K  M[K]   M'[K]
                  ; CAR                                                       # S  K  M[K]  M'[K]
                  ; COMPARE ; EQ                                              # S=K  M[K]  M'[K]
                  ; IF { TRACE("==") ; PUSH nat 1; ADD ; COMPARE ; EQ }       # M[K]+1=M'[K]
                       { TRACE("!=") ;                   COMPARE ; EQ }       # M[K] = M'[K]
                  }
                }
             }
