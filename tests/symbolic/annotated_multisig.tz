parameter (or (unit %default)
              (pair %main
                 (pair :payload
                    (nat %counter) # counter, used to prevent replay attacks
                    (or :action    # payload to sign, represents the requested action
                       (lambda %operation unit (list operation))
                       (pair %change_keys          # change the keys controlling the multisig
                          (nat %threshold)         # new threshold
                          (list %keys key))))     # new list of keys
                 (list %sigs (option signature))));    # signatures

storage (pair (nat %stored_counter) (pair (nat %threshold) (list %keys key))) ;

code
  {
    UNPAIR ;
    IF_LEFT
      { # Default entry point: do nothing
        # This entry point can be used to send tokens to this contract
        DROP ; NIL operation ; PAIR }
      { # Main entry point
        # Assert no token was sent:
        # to send tokens, the default entry point should be used
        PUSH mutez 0 ; AMOUNT ; ASSERT_CMPEQ ;
        SWAP ; DUP ; DIP { SWAP } ;
        DIP
          {
            UNPAIR ;
            # pair the payload with the current contract address, to ensure signatures
            # can't be replayed accross different contracts if a key is reused.
            DUP ; SELF ; ADDRESS ; CHAIN_ID ; PAIR ; PAIR ;
            PACK ; # form the binary payload that we expect to be signed
            DIP { UNPAIR @counter ; DIP { SWAP } } ; SWAP
          } ;

        # Check that the counters match
        UNPAIR @stored_counter; DIP { SWAP };
        ASSERT_CMPEQ ;

        # Compute the number of valid signatures
        DIP { SWAP } ; UNPAIR @threshold @keys;
        DIP
          {
            # Running count of valid signatures
            PUSH @valid nat 0; SWAP ;
            ITER { #  [ @keys.elt key : @valid nat : list (option signature) : @packed bytes
                   #  : or :action
                   #    (lambda %operation unit (list operation))
                   #    (pair %change_keys (nat %threshold) (list %keys key))
                   #  : @storage pair (nat %stored_counter) (pair (nat %threshold) (list %keys key)) ]
                DIP { SWAP } ; SWAP ;
                IF_CONS
                             # sigs.hd sigs.tl @keys.elt @valid ...
                  {
                    IF_SOME     # sigs.hd.v sigs.tl @keys.elt @valid ...
                      { SWAP ;  # sigs.tl sigs.hd.v @keys.elt @valid ...
                        DIP     # sigs.tl | sigs.hd.v @keys.elt @valid ...
                          {
                            SWAP ; DIIP { DUUP } ;
                            # Checks signatures, fails if invalid
                            # [ @keys.elt key : @hd.some signature : @packed bytes
                            #   : @valid nat
                            #   : @packed bytes
                            #   : or :action
                            #     (lambda %operation unit (list operation))
                            #     (pair %change_keys (nat %threshold) (list %keys key))
                            #   : @storage pair (nat %stored_counter) (pair (nat %threshold) (list %keys key)) ]
                            { DUUUP; DIP {CHECK_SIGNATURE}; SWAP; IF {DROP} {FAILWITH} };
                            PUSH nat 1 ; ADD @valid } }
                      { SWAP ; DROP }
                  }
                  {
                    # There were fewer signatures in the list
                    # than keys. Not all signatures must be present, but
                    # they should be marked as absent using the option type.
                    FAIL
                  } ;
                SWAP
              }
              # postcondition: if we haven't failed, then
              # 1. list option sig and list keys have the same size
              # 2. forall 0 <= i <= len(list keys) : if sigs[i] == Some V then (CHECK_SIGNATURE keys[i] sigs[i] payload)
              # 3. valid == sum of set signatures

              # initial loop body stack =>
              # final loop body stack ???
              # at(loop1, x) x
              # iter_invariant key valid sigs bytes action storage {
              #
              #   1. PUSH list (option signature) sigs ; IF_CONS { } { FAIL }
              #   2. PUSH list (option signature) sigs ; IF_CONS { IF_NONE { PUSH bool True ; } { PUSH ... ; CHECK_SIGNATURE } } { FAIL }
              #
              #   3. IF (2) => PUSH nat at(iter, valid) ; PUSH nat 1 ; ADD ; PUSH nat valid ; COMPARE ; EQ
              #   4. tail(at(loop1, sigs)) == sigs
              # }

          } ;
        # Assert that the threshold is less than or equal to the
        # number of valid signatures.
        ASSERT_CMPLE ;
        # Assert no unchecked signature remains
        IF_CONS {FAIL} {} ;
        DROP ;

        # Increment counter and place in storage
        DIP { UNPAIR ; PUSH nat 1 ; ADD @new_counter ; PAIR} ;

        # We have now handled the signature verification part,
        # produce the operation requested by the signers.
        IF_LEFT
          { # Get operation
            UNIT ; EXEC
          }
          {
            # Change set of signatures
            DIP { CAR } ; SWAP ; PAIR ; NIL operation
          };
        PAIR }
  }

# TODO: fix this predicate definition
#
# Add new predicate to use in assertion
#
# function $ALL_VALID lambda (pair (list (option signature)) (pair (list key) bytes)) bool
# { UNPAPAIR ; # sigs keys bytes
#   IF_CONS {                            # sigs.hd sigs.tl keys bytes
#             DIG 2 ;                    # keys sigs.hd sigs.tl bytes
#             IF_CONS {                  # keys.hd keys.tl sigs.hd sigs.tl bytes
#                       DIG 2 ;          # sigs.hd keys.hd keys.tl sigs.tl bytes
#                       IF_NONE {        # keys.hd keys.tl sigs.tl bytes
#                                 DROP ; SWAP ; PAPAPAIR ; PUSH lambda (pair (list (option signature)) (pair (list key) bytes)) bool $ALL_VALID ; EXEC ;
#                               }
#                               {
#
#                               }
#                     }
#                     { DROP 3 ; PUSH bool False } # drop everything and return false
#           }
#           { # keys bytes
#             IF_CONS { PUSH bool False } # sigs list is nil but keys list is not => fail
#                     { PUSH bool True  } # both lists nil => ok
#           }
# }
