<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
/>
<meta
  name="description"
  content="A Michelson semantics for Tezos built using the K Framework."
/>
<meta name="keywords" content="runtime, verification, rv, k" />
<meta name="author" content="Michelson Semantics | Runtime Verification Inc" />
<meta name="robots" content="index, follow" />

<!--favicon icon-->
<!-- <link rel="icon" type="image/png" href="../../../../assets/img/favicon.ico" /> -->

<title>Michelson Semantics | Runtime Verification Inc</title>

<!-- <base href="/k/" /> -->

<!--web fonts-->
<link
  href="https://fonts.googleapis.com/css?family=Nunito:300,400,600,700,800"
  rel="stylesheet"
/>
<link
  href="https://fonts.googleapis.com/css?family=Lora:400i"
  rel="stylesheet"
/>

<link
  href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"
  rel="stylesheet"
/>

<link href="../../../../assets/css/index.css" rel="stylesheet" />

<!--[if (gt IE 9) |!(IE)]><!-->
<!--<link rel="stylesheet" href="/assets/vendor/custom-nav/css/effects/fade-menu.css"/>-->
<!-- <link rel="stylesheet" href="../../../../assets/k/vl-nav/css/effects/slide-menu.css" /> -->
<!--<![endif]-->

  </head>

  <body>
<header
  class="navbar navbar-expand navbar-dark flex-column flex-md-row bd-navbar"
>
  <a class="logo-link" href="../../../../index.html"> Michelson Semantics </a>
  <ul class="navbar-nav ml-md-auto">
    <li class="nav-item">
      <a
        class="nav-link pl-2 pr-1 mx-1 py-3 my-n2"
        href="https://github.com/runtimeverification/michelson-semantics"
        target="_blank"
        rel="noopener"
        aria-label="GitHub"
      >
        <i class="fab fa-github"></i>
      </a>
    </li>
  </ul>
  <!--
  <a
    class="btn btn-rv-blue d-none d-lg-inline-block mb-3 mb-md-0 ml-md-3"
    href="../../../../downloads"
    >Download</a
  >
  -->
</header>


    <div class="container-fluid">
      <div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 bd-sidebar mb-3">
  <form
    role="search"
    class="bd-search d-flex align-items-center justify-content-between"
  >
    <input
      type="search"
      class="form-control"
      placeholder="Search..."
      aria-label="Search for..."
      autocomplete="false"
      id="search-box"
    />
    <button
      class="btn bd-search-docs-toggle d-md-none p-0 ml-3 collapsed"
      type="button"
      aria-label="Toggle docs navigation"
      style="font-size: 1.4rem"
    >
      <i class="fas fa-bars"></i>
    </button>
  </form>
  <nav class="collapse bd-links" aria-label="Main navigation">
    <div class="bd-toc-item">
      <a class="bd-toc-link" href="../../../../">Homepage</a>
      <a class="bd-toc-link" href="../../../../INSTALL">Install</a>
      <a class="bd-toc-link" href="../../../../USER_GUIDE">User Guide</a>
    </div>
  </nav>
</div>

        <main
          class="col-12 col-md-6 col-xl-8 py-md-3 pl-md-5 bd-content"
          role="main"
        >
          <div class="markdown-preview"><html><head></head><body><h1 id="liquidity-baking-safety-property-proofs">Liquidity Baking Safety Property Proofs</h1>
<p>This document is all about proving two safety properties for the liquidity baking (LB) system which includes three separate smart contracts that we refer to as <em>Dexter</em>, <em>LQT</em>, and <em>tzBTC</em>.
We assume that the reader is familiar with Uniswap-style CPMMs and the basic LB system structure.
See the <a href="../">README</a> for an overview of relevant background material, including a description of the safety properties we wish to prove.
For convenience, we restate our desired safety properties here:</p>
<ul>
<li><em>Liquidity share value security</em> - LP shares never decrease in <em>redemption value</em> (note this is <em>different</em> from <em>monetary value</em>, see below)</li>
<li><em>Operation safety</em> - all trades and liquidity redemptions/deposits have a bounded exchange rate and time in which they are applicable.</li>
</ul>
<p>Our proof occurs in several parts.</p>
<p><em>(a)</em> The first part is a mechanized proof that high-level K specifications are consistent with the low-level Michelson code of the <em>Dexter</em> and <em>LQT</em> smart contracts.
The proof scripts are contained in the <a href="../lb/">lb.md</a> and <a href="https://github.com/runtimeverification/michelson-semantics/tree/master/lb-spec">lb-spec.md</a> and <a href="../../lqt/lqt/">lqt.md</a> and <a href="../../lqt/lqt-spec/">lqt-spec.md</a> files.
Note that do not provide similar mechanized proofs for the <em>tzBTC</em> contract since it is an <em>upgradeable</em> contract whose logic may vary over time.
Instead, we axiomatize how we expect this contract to behave in our assumptions section below, such that our proofs will hold if the <em>tzBTC</em> satisfies the required assumptions.</p>
<p><em>(b)</em> The second part contains by-hand proofs for safety properties (1)-(2) based on the results from part <em>(a)</em>.
Before diving into the details, see the proof sketch below.</p>
<h2 id="proof-sketch">Proof Sketch</h2>
<p>The proof of the <em>operation safety</em> property is more straightforward.
It follows from the K specification definitions and the assumptions about external smart contracts listed below.
On the other hand, the proof of the <em>liquidity share value security</em> property is non-trivial.
This proof occurs in two steps:</p>
<ul>
<li>we prove a <em>state variable faithfulness</em> invariant, i.e., <em>Dexter</em> contract variables are consistent with particular balances/storage values in the <em>Dexter</em>, <em>LQT</em>, and <em>tzBTC</em> contracts;</li>
<li>we use this lemma to prove the <em>liquidity share value security</em> property</li>
</ul>
<p>There are many other lemmas used along the way that we will mention as needed.
Before diving into our proof, we start with the needed notation and assumptions.</p>
<h2 id="notation">Notation</h2>
<p>To simplify our description of entrypoint behavior, we write entrypoint names like functions which take arguments.
Given that each contract has a fixed number of important entrypoints, we list them all here for reference:</p>
<p><em>LB</em> Entrypoints:</p>
<ul>
<li><code>AddLiquidity(owner : Address, minLqtMinted : Nat, maxTokensDeposited : Nat, deadline : Timestamp)</code></li>
<li><code>RemoveLiquidity(to : Address, lqtBurned : Nat, minXtzWithdrawn : Mutez, minTokensWithdrawn : Nat, deadline : Timestamp)</code></li>
<li><code>Default</code></li>
<li><code>XtzToToken(to : Address, minTokensBought : Nat, deadline : Timestamp)</code></li>
<li><code>TokenToXtz(to : Address, tokensSold : Nat, minXtzBought : Mutez, deadline : Timestamp)</code></li>
<li><code>TokenToToken(outputDexterContract : Address, minTokensBought : Nat, to : Address, tokensSold : Nat, deadline : Timestamp)</code></li>
</ul>
<p><em>LQT</em> Entrypoints (includes the FA1.2 entrypoints as well as <code>MintOrBurn</code>):</p>
<ul>
<li><code>GetTotalSupply(callback: Entrypoint)</code></li>
<li><code>GetBalance(owner: Address, callback: Entrypoint)</code></li>
<li><code>GetAllowance(owner: Address, spender: Address, callback: Entrypoint)</code></li>
<li><code>Approve(spender: Address, value: Nat)</code></li>
<li><code>Transfer(from: Address, to: Address, value: Nat)</code></li>
<li><code>MintOrBurn(quantity: Int, target: Address)</code></li>
</ul>
<p><em>tzBTC</em> Entrypoints (since this contract is FA1.2 compliant, it should include at least these entrypoints):</p>
<ul>
<li><code>GetTotalSupply(callback: Entrypoint)</code></li>
<li><code>GetBalance(owner: Address, callback: Entrypoint)</code></li>
<li><code>GetAllowance(owner: Address, spender: Address, callback: Entrypoint)</code></li>
<li><code>Approve(spender: Address, value: Nat)</code></li>
<li><code>Transfer(from: Address, to: Address, value: Nat)</code></li>
</ul>
<h2 id="assumptions-for-tezos-execution-environment">Assumptions for Tezos Execution Environment</h2>
<p>We assume that the Tezos execution model does not allow any weird behaviors regarding the Dexter smart contract execution.  Specifically, we make the following assumptions:</p>
<ul>
<li>Only the Dexter entrypoint functions can emit operations whose sender is Dexter.</li>
<li>As a smart contract, Dexter can emit only <em>internal</em> operations (i.e., operations whose source is not Dexter).</li>
<li>The types of Dexter-emitted internal operations are fixed (i.e., no arbitrary operations can be emitted by Dexter).</li>
<li>Dexter <em>never</em> calls on itself except the following cases:
<ul>
<li>RemoveLiquidity(To, ...) where To is Dexter, which calls Default() on itself.</li>
<li>TokenToXtz(To, ...) where To is Dexter, which calls Default() on itself.</li>
<li>TokenToToken(OutputDexterContract, ...) where OutputDexterContract is Dexter, which calls XtzToToken() on itself.</li>
</ul>
</li>
</ul>
<p>The above assumptions are formulated in a series of propositions below.</p>
<p>The following proposition <code>[sender-is-not-dexter]</code> states that no entrypoint of Dexter may call on itself except Default() and XtzToToken().</p>
<pre class="language-text"><code>proposition [sender-is-not-dexter]:
[[ Sender =/=K DEXTER =&gt; true ]]
&lt;operations&gt; [ Transaction Sender DEXTER _ CallParams ] ;; _ &lt;/operations&gt;
requires CallParams ==K AddLiquidity _
  orBool CallParams ==K RemoveLiquidity _
  orBool CallParams ==K TokenToXtz _
  orBool CallParams ==K TokenToToken _
</code></pre>
<p>The following proposition <code>[dexter-emitted-ops]</code> enumerates all possible Dexter-emitted operations.</p>
<pre class="language-text"><code>proposition [dexter-emitted-ops]:
[[ (
          ( Target ==K TOKEN andBool Amount ==Int 0 andBool CallParams ==K (Transfer _) )
   orBool ( Target ==K LQT   andBool Amount ==Int 0 andBool CallParams ==K (MintBurn _) )
   orBool (                                                 CallParams ==K Default() )
   orBool (                                                 CallParams ==K (XtzToToken _) )
   ) =&gt; true ]]
&lt;operations&gt; [ Transaction DEXTER Target Amount CallParams ] ;; _ &lt;/operations&gt;
</code></pre>
<p>The following proposition <code>[only-dexter]</code> states that no one other than Dexter can emit operations whose sender is Dexter.  Note that Sends, Transfers, and MintBurns are defined to be zero for operations whose sender is not Dexter.  Also, obviously, the state variables and XTZ balance of Dexter cannot be updated without executing the Dexter contract.</p>
<pre class="language-text"><code>proposition [only-dexter]:
&lt;operations&gt; ( [ Transaction _ Target _ _ ] =&gt; Ops ) ;; _ &lt;/operations&gt;
&lt;xtzPool&gt;         #Mutez(X =&gt; X')   &lt;/xtzPool&gt;
&lt;tokenPool&gt;              T =&gt; T'    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;               L =&gt; L'    &lt;/lqtTotal&gt;
&lt;dexter.balance&gt;  #Mutez(B =&gt; B')   &lt;/dexter.balance&gt;
requires Target =/=K DEXTER
ensures  Sends(Ops) ==Int 0
 andBool Transfers(Ops) ==Int 0
 andBool MintBurns(Ops) ==Int 0
 andBool X' ==Int X
 andBool T' ==Int T
 andBool L' ==Int L
 andBool B' ==Int B
</code></pre>
<p>The following proposition <code>[top-level]</code> states that a top-level operation (i.e., an operation whose sender is equal to the source) cannot be generated by Dexter.</p>
<pre class="language-text"><code>proposition [top-level]:
[[ Sender ==K Source impliesBool Sender =/=K DEXTER =&gt; true ]]
&lt;operations&gt; [ Transaction Sender _ _ _ ] ;; Ops &lt;/operations&gt;
&lt;sourceaddr&gt; Source &lt;/sourceaddr&gt;
</code></pre>
<p>The DFS execution model guarantees that if the current operation is top-level, then all the continuation operations are top-level with the same sender which is the source.  The following proposition <code>[dfs]</code> formulates that.</p>
<pre class="language-text"><code>proposition [dfs]:
[[ Sender ==K Source impliesBool TopLevelOps(Ops, Source) =&gt; true ]]
&lt;operations&gt; [ Transaction Sender _ _ _ ] ;; Ops &lt;/operations&gt;
&lt;sourceaddr&gt; Source &lt;/sourceaddr&gt;

syntax Bool ::= TopLevelOps(OpList, Address) [function]
rule TopLevelOps([ Transaction Sender _ _ _ ] ;; Ops, Source) =&gt; TopLevelOps(Ops, Source)
  requires Sender ==K Source
rule TopLevelOps([ Transaction Sender _ _ _ ] ;; _, Source) =&gt; false
  requires Sender =/=K Source
rule TopLevelOps(.List, _) =&gt; true
</code></pre>
<h2 id="requirements-for-external-contracts">Requirements for External Contracts</h2>
<p>We make assumptions on the behaviors of external contracts, especially the token and liquidity contracts.  <em><strong>These assumptions are required for the proof of the invariant, and thus it is important to verify that these are satisfied by the given implementation of the token and liquidity contracts.</strong></em>  If some of these assumptions are not satisfied for good reasons, then the proof needs to be revisited.</p>
<p>We assume that <em>only</em> Dexter can spend its own token, and no others can.  Specifically, for example, there must <em>not</em> exist any authorized users who are permitted to spend (some of) Dexter-owned tokens (in any certain cases).  For another example, there must <em>not</em> exist a way to (even temporarily) borrow tokens from Dexter.</p>
<p>We also assume that the token transfer operation must update the balance before emitting continuation operations.  For example, the token contract must <em>not</em> implement the so-called "pull pattern" where the transfer operation does not immediately update the balance but only allows the receiver to claim the transferred amount later as a separate transaction.</p>
<p>These assumptions are formulated in the following proposition <code>[token-transfer]</code>.</p>
<pre class="language-text"><code>rule [token-transfer]:
&lt;operations&gt; ( [ Transaction Sender TOKEN Amount Transfer(From, To, Value) ] =&gt; Ops' ) ;; Ops &lt;/operations&gt;
&lt;tokenDexter&gt; D =&gt; D' &lt;/tokenDexter&gt;
assert   Amount ==Int 0
 andBool From ==K DEXTER impliesBool Sender ==K DEXTER
ensures  ( From  ==K DEXTER andBool To =/=K DEXTER ) impliesBool D' ==Int D -Int Value
 andBool ( From =/=K DEXTER andBool To  ==K DEXTER ) impliesBool D' ==Int D +Int Value
 andBool ( From  ==K DEXTER andBool To  ==K DEXTER ) impliesBool D' ==Int D
 andBool ( From =/=K DEXTER andBool To =/=K DEXTER ) impliesBool D' ==Int D
</code></pre>
<p>Moreover, we assume that the only way to alter the token balance of Dexter is the Transfer() function call.  No other functions can affect the token balance of Dexter.  The following proposition formulates that.</p>
<pre class="language-text"><code>proposition [only-token-transfer]:
&lt;operations&gt; (Op =&gt; _) ;; _ &lt;/operations&gt;
&lt;tokenDexter&gt; D =&gt; D' &lt;/tokenDexter&gt;
ensures  D' &lt;Int D impliesBool (         Op ==K Transaction DEXTER TOKEN 0 Transfer(DEXTER, To, Value)
                                 andBool To =/=K DEXTER
                                 andBool Value &gt;Int 0
                               )
 andBool D' &gt;Int D impliesBool Op ==K Transaction _ TOKEN 0 Transfer(_, DEXTER, _)
</code></pre>
<p>For the LQT Token contract, we require one safety property and another liveness property
that together state that the total number of liquidity shares may be updated if and only if
the LB Dexter contract calls the <code>%mintOrBurn</code> entrypoint. Both these are proved in <a href="../../lqt/lqt-properties/">lqt-properties.md</a>.</p>
<p>For the other unknown external contract calls, the only functions Dexter can call are Default() and XtzToToken().  We assume that such external calls can affect only the XTZ balance of Dexter (even if the target contract is the token or liquidity contract).  The following rule <code>[send]</code> formulates that.</p>
<pre class="language-text"><code>rule [send]:
&lt;operations&gt; ( [ Transaction DEXTER Target Amount CallParams ] =&gt; Ops' ) ;; _ &lt;/operations&gt;
&lt;dexter.balance&gt; #Mutez(B =&gt; B -Int Amount) &lt;/dexter.balance&gt;
requires Target =/=K DEXTER
 andBool ( CallParams ==K Default() orBool CallParams ==K (XtzToToken _) )
</code></pre>
<h2 id="state-variable-faithfulness">State Variable Faithfulness</h2>
<p>In the Dexter contract, the token exchange rate and the liquidity share price are determined by the three state variables (XtzPool, TokenPool, LqtTotal) which keep track of the XTZ reserve, the token (tzBTC) reserve, and the total liquidity token supply, respectively.</p>
<p>The first invariant we consider is that the Dexter state variables faithfully represent the actual pool reserves and liquidity supply.  That is, XtzPool and TokenPool must be equal to the actual XTZ and token reserves, and LqtTotal must be equal to the actual total liquidity supply. We show this holds inductively, i.e. we assume that the invariant is satisfied, and then show that no sequence of transactions can cause it to be violated.</p>
<p>Note that the Dexter entrypoint functions immediately update these state variables, while the actual reserves or supply will be updated later by the continuation operations emitted by the entrypoints.  Moreover, the actual token reserve may be possibly larger than TokenPool, since one can "donate" tokens to Dexter (i.e., directly sending tokens to Dexter without going through any of the Dexter entrypoint functions).  Note that, however, the actual XTZ reserve must be equal to the XtzPool value, since directly sending XTZ to Dexter will be captured by the Default() entrypoint.  (Indeed, we assume that, in Tezos, there is no way to "secretly" send XTZ to Dexter without triggering any Dexter entrypoint.  Note that, in Ethereum, it is <em>possible</em> to send Ether to a smart contract without ever executing the contract code, either by making the contract the recipient of mining rewards or selfdestruct rewards.)</p>
<p>The following claim <code>[inv-top-level]</code> states that the invariant holds at the completion of every top-level operation.  Note that a top-level operation is the one created by an implicit account (i.e., an operation whose sender is equal to the source), and the completion of an operation involves the full execution "tree" following the DFS model adopted in the Florence upgrade.</p>
<p>The <code>&lt;xtzPool&gt;</code>, <code>&lt;tokenPool&gt;</code>, and <code>&lt;lqtTotal&gt;</code> cells denote the Dexter state variables, XtzPool, TokenPool, and LqtTotal, respectively.  The <code>&lt;dexter.balance&gt;</code>, <code>&lt;tokenDexter&gt;</code>, and <code>&lt;lqt.totalSupply&gt;</code> cells denote the actual XTZ and token reserves, and total liquidity supply, respectively.</p>
<pre class="language-text"><code>claim [inv-top-level]:
&lt;operations&gt; ( [ Transaction Sender _ _ _ ] #as Op =&gt;* .List ) ;; Ops &lt;/operations&gt;
&lt;xtzPool&gt;           #Mutez(X =&gt; X')   &lt;/xtzPool&gt;
&lt;tokenPool&gt;                T =&gt; T'    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;                 L =&gt; L'    &lt;/lqtTotal&gt;
&lt;dexter.balance&gt;    #Mutez(B =&gt; B')   &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;              D =&gt; D'    &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;          S =&gt; S'    &lt;/lqt.totalSupply&gt;
&lt;sourceaddr&gt;        Source            &lt;/sourceaddr&gt;
requires Sender ==K Source
 andBool 0 &lt;Int X  andBool X  ==Int B
 andBool 0 &lt;Int T  andBool T  &lt;=Int D
 andBool 0 &lt;Int L  andBool L  ==Int S
ensures  0 &lt;Int X' andBool X' ==Int B'
 andBool 0 &lt;Int T' andBool T' &lt;=Int D'
 andBool 0 &lt;Int L' andBool L' ==Int S'

proof [inv-top-level]:
- Sender =/=K DEXTER by [top-level]
- TopLevelOps(Ops, Source) by [dfs]
- by Sender =/=K DEXTER and TopLevelOps(Ops, Source) derive:
          Sends(Op ;; Ops)     ==Int 0
  andBool Transfers(Op ;; Ops) ==Int 0
  andBool MintBurns(Op ;; Ops) ==Int 0
- apply [inv-trans]
- unify RHS
  - Ops' == .List
- Sends(Ops) ==Int 0 andBool Transfers(Ops) ==Int 0 andBool MintBurns(Ops) ==Int 0 by Sender =/=K DEXTER
- Sends(Ops' ;; Ops) ==Int 0 andBool Transfers(Ops' ;; Ops) ==Int 0 andBool MintBurns(Ops' ;; Ops) ==Int 0 by Ops'
- qed
</code></pre>
<pre class="language-text"><code>claim [inv-trans]:
&lt;operations&gt;      (Op =&gt;* Ops') ;; Ops &lt;/operations&gt;
&lt;xtzPool&gt;          #Mutez(X =&gt; X')     &lt;/xtzPool&gt;
&lt;tokenPool&gt;               T =&gt; T'      &lt;/tokenPool&gt;
&lt;lqtTotal&gt;                L =&gt; L'      &lt;/lqtTotal&gt;
&lt;dexter.balance&gt;   #Mutez(B =&gt; B')     &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;             D =&gt; D'      &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;         S =&gt; S'      &lt;/lqt.totalSupply&gt;
requires 0 &lt;Int X  andBool X  ==Int B  +Int Sends(Op ;; Ops)
 andBool 0 &lt;Int T  andBool T  &lt;=Int D  +Int Transfers(Op ;; Ops)
 andBool 0 &lt;Int L  andBool L  ==Int S  +Int MintBurns(Op ;; Ops)
ensures  0 &lt;Int X' andBool X' ==Int B' +Int Sends(Ops' ;; Ops)
 andBool 0 &lt;Int T' andBool T' &lt;=Int D' +Int Transfers(Ops' ;; Ops)
 andBool 0 &lt;Int L' andBool L' ==Int S' +Int MintBurns(Ops' ;; Ops)

proof [inv-trans]:
- by induction on =&gt;* and [inv]
</code></pre>
<p>The following claim <code>[inv]</code> generalizes the top-level claim <code>[inv-top-level]</code> over every intermediate operation.  It says that the execution of an <em>arbitrary</em> operation always preserves a certain relationship between the Dexter state variables and the actual pool reserves and liquidity supply.  Intuitively, the Dexter state variables must reflect the "ultimate" value of the pool reserves and liquidity supply over the course of intermediate steps of execution, which will be eventualy updated by the continuation operations in the future.</p>
<pre class="language-text"><code>claim [inv]:
&lt;operations&gt;     (Op =&gt; Ops') ;; Ops &lt;/operations&gt;
&lt;xtzPool&gt;          #Mutez(X =&gt; X')   &lt;/xtzPool&gt;
&lt;tokenPool&gt;               T =&gt; T'    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;                L =&gt; L'    &lt;/lqtTotal&gt;
&lt;dexter.balance&gt;   #Mutez(B =&gt; B')   &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;             D =&gt; D'    &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;         S =&gt; S'    &lt;/lqt.totalSupply&gt;
requires 0 &lt;Int X  andBool X  ==Int B  +Int Sends(Op ;; Ops)
 andBool 0 &lt;Int T  andBool T  &lt;=Int D  +Int Transfers(Op ;; Ops)
 andBool 0 &lt;Int L  andBool L  ==Int S  +Int MintBurns(Op ;; Ops)
ensures  0 &lt;Int X' andBool X' ==Int B' +Int Sends(Ops' ;; Ops)
 andBool 0 &lt;Int T' andBool T' &lt;=Int D' +Int Transfers(Ops' ;; Ops)
 andBool 0 &lt;Int L' andBool L' ==Int S' +Int MintBurns(Ops' ;; Ops)
</code></pre>
<p>Specifically, Sends(Ops) denotes the amount of XTZ that will be sent to others by the operations Ops, Transfers(Ops) denotes the amount of tokens that will be sent to or received from others by Ops, and MintBurns(Ops) denotes the amount of liquidity that will be minted or burned by Ops.  Thus, the difference between the Dexter state variable XtzPool and the current XTZ reserve must be equal to Sends(Ops), the difference between TokenPool and the current token reserve must be equal to Transfers(Ops), and the difference between LqtTotal and the current liquidity supply must be equal to MintBurns(Ops), where Ops is the current continuation operations to be executed.</p>
<p>Note that Sends, Transfers, and MintBurns count only Dexter-emitted operations, thus they are defined to be zero for operations that are not generated by Dexter.  (See the proposition <code>[only-dexter]</code>.)  Since no top-level operations can be generated by Dexter, they are defined to be zero for any top-level operations.</p>
<pre class="language-text"><code>syntax Int ::= Sends(OpList) [function]
rule Sends([ Transaction DEXTER _ X _ ] ;; Ops) =&gt; Sends(Ops) -Int X
rule Sends(_ ;; Ops) =&gt; Sends(Ops) [owise]
rule Sends(.List) =&gt; 0

syntax Int ::= Transfers(OpList) [function]
rule Transfers([ Transaction DEXTER TOKEN 0 Transfer(From, To, T) ] ;; Ops) =&gt; Transfers(Ops) +Int T
  when From =/=K DEXTER andBool To ==K DEXTER
rule Transfers([ Transaction DEXTER TOKEN 0 Transfer(From, To, T) ] ;; Ops) =&gt; Transfers(Ops) -Int T
  when From  ==K DEXTER
rule Transfers(_ ;; Ops) =&gt; Transfers(Ops) [owise]
rule Transfers(.List) =&gt; 0

syntax Int ::= MintBurns(OpList) [function]
rule MintBurns([ Transaction DEXTER LQT 0 MintOrBurn(_, L) ] ;; Ops) =&gt; MintBurns(Ops) +Int L
rule MintBurns(_ ;; Ops) =&gt; MintBurns(Ops) [owise]
rule MintBurns(.List) =&gt; 0
</code></pre>
<p>Below we prove the claim <code>[inv]</code> by the induction on sequences of operations, and the case analysis over different types of operations.</p>
<pre class="language-text"><code>proof [inv]:
- assume that the invariant has held in each of the previous operations
- let Op = Transaction Sender Target Amount CallParams
- split Sender, Target
  - case Sender &lt;&gt; DEXTER and Target == DEXTER
    - split CallParams
      - case CallParams == AddLiquidity _
        - apply [inv-add-liquidity]
      - case CallParams == RemoveLiquidity _
        - apply [inv-remove-liquidity]
      - case CallParams == XtzToToken _
        - apply [inv-xtz-to-token]
      - case CallParams == TokenToXtz _
        - apply [inv-token-to-xtz]
      - case CallParams == TokenToToken _
        - apply [inv-token-to-token]
      - case CallParams == Default _
        - apply [inv-default]
  - case Sender == DEXTER and Target == DEXTER
    - split CallParams
      - case CallParams == XtzToToken _
        - apply [inv-xtz-to-token]
      - case CallParams == Default _
        - apply [inv-default]
      - case _
        - apply [sender-is-not-dexter]
  - case Sender == DEXTER and Target &lt;&gt; DEXTER
    - split Op
      - case Op == Transaction DEXTER TOKEN 0 (Transfer _)
        - apply [inv-token-transfer]
      - case Op == Transaction DEXTER LQT 0 (MintOrBurn _)
        - apply [inv-lqt-mint-burn]
      - case Op == Transaction DEXTER _ _ Default()
        - apply [inv-send]
      - case Op == Transaction DEXTER _ _ (XtzToToken _)
        - apply [inv-send]
      - case _
        - apply [dexter-emitted-ops]
  - case Sender &lt;&gt; DEXTER and Target &lt;&gt; DEXTER
    - Sends(Op) == Transfers(Op) == MintBurns(Op) == 0 by Sends, Transfers, MintBurns
    - Sends(Ops') == Transfers(Ops') == MintBurns(Ops') == 0 by [only-dexter]
    - split Target
      - case Target == TOKEN
        - (X', T', L', B') == (X, T, L, B) by [only-dexter]
        - S' == S by [only-lqt-mint-burn]
        - split CallParams
          - case CallParams == Transfer(From, To, Value)
            - From &lt;&gt; DEXTER by [token-transfer]'s assertion
            - D' &gt;= D by [only-token-transfer]
          - case CallParams &lt;&gt; (Transfer _)
            - D' &gt;= D by [only-token-transfer]
      - case Target == LQT
        - (X', T', L', B') == (X, T, L, B) by [only-dexter]
        - D' == D by [only-token-transfer]
        - CallParams &lt;&gt; (MintOrBurn _) by [lqt-mint-burn]
          - S' == S
      - case Target &lt;&gt; TOKEN and Target &lt;&gt; LQT
        - (X', T', L', B') == (X, T, L, B) by [only-dexter]
        - D' == D by [only-token-transfer]
        - S' == S by [only-lqt-mint-burn]
</code></pre>
<h3 id="proof-for-dexter-entrypoint-functions">Proof for Dexter Entrypoint Functions</h3>
<p>We prove the claim <code>[inv]</code> for each Dexter entrypoint.</p>
<h4 id="addliquidity">AddLiquidity</h4>
<pre class="language-text"><code>claim [inv-add-liquidity]:
&lt;operations&gt;   ( [ Transaction Sender DEXTER XtzDeposited AddLiquidity(Owner, _, _, _) ] #as Op =&gt; Ops' )
            ;; Ops
&lt;/operations&gt;
&lt;xtzPool&gt;          #Mutez(X =&gt; X')   &lt;/xtzPool&gt;
&lt;tokenPool&gt;               T =&gt; T'    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;                L =&gt; L'    &lt;/lqtTotal&gt;
&lt;dexter.balance&gt;   #Mutez(B =&gt; B')   &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;             D =&gt; D'    &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;         S =&gt; S'    &lt;/lqt.totalSupply&gt;
requires 0 &lt;Int X  andBool X  ==Int B  +Int Sends(Op ;; Ops)
 andBool 0 &lt;Int T  andBool T  &lt;=Int D  +Int Transfers(Op ;; Ops)
 andBool 0 &lt;Int L  andBool L  ==Int S  +Int MintBurns(Op ;; Ops)
ensures  0 &lt;Int X' andBool X' ==Int B' +Int Sends(Ops' ;; Ops)
 andBool 0 &lt;Int T' andBool T' &lt;=Int D' +Int Transfers(Ops' ;; Ops)
 andBool 0 &lt;Int L' andBool L' ==Int S' +Int MintBurns(Ops' ;; Ops)

proof [inv-add-liquidity]:
- Sender =/=K DEXTER by [sender-is-not-dexter]
- apply [add-liquidity]
- unify RHS
  - Ops' == ( [ Transaction DEXTER TOKEN 0 Transfer(Sender, DEXTER, TokensDeposited) ] #as Op1 )
         ;; ( [ Transaction DEXTER LQT 0 MintOrBurn(Owner, LqtMinted) ] #as Op2 )
  - X' == X +Int XtzDeposited
  - T' == T +Int ( XtzDeposited *Int T up/Int X #as TokensDeposited )
  - L' == L +Int ( XtzDeposited *Int L   /Int X #as LqtMinted )
  - B' == B +Int XtzDeposited
  - D' == D
  - S' == S
- X' &gt;Int 0 by X &gt;Int 0 and XtzDeposited &gt;=Int 0
- T' &gt;Int 0 by T &gt;Int 0 and TokensDeposited &gt;=Int 0
- L' &gt;Int 0 by L &gt;Int 0 and LqtMinted &gt;=Int 0
- X' ==Int X +Int XtzDeposited
     ==Int B +Int Sends(Op ;; Ops) +Int XtzDeposited by premise
     ==Int B' +Int Sends(Op ;; Ops) by B'
     ==Int B' +Int Sends(Ops) by Sends and Sender =/=K DEXTER
     ==Int B' +Int Sends(Op2 ;; Ops) by Sends
     ==Int B' +Int Sends(Op1 ;; Op2 ;; Ops) by Sends
     ==Int B' +Int Sends(Ops' ;; Ops) by Ops'
- T' ==Int T +Int TokensDeposited
     &lt;=Int D +Int Transfers(Op ;; Ops) +Int TokensDeposited by premise
     ==Int D' +Int Transfers(Op ;; Ops) +Int TokensDeposited by D'
     ==Int D' +Int Transfers(Ops) +Int TokensDeposited by Transfers
     ==Int D' +Int Transfers(Op2 ;; Ops) +Int TokensDeposited by Transfers
     ==Int D' +Int Transfers(Op1 ;; Op2 ;; Ops) by Transfers and Sender =/=K DEXTER
     ==Int D' +Int Transfers(Ops' ;; Ops) by Ops'
- L' ==Int L +Int LqtMinted
     ==Int S +Int MintBurns(Op ;; Ops) +Int LqtMinted by premise
     ==Int S' +Int MintBurns(Op ;; Ops) +Int LqtBurned by S'
     ==Int S' +Int MintBurns(Ops) +Int LqtBurned by MintBurns
     ==Int S' +Int MintBurns(Op2 ;; Ops) by MintBurns
     ==Int S' +Int MintBurns(Op1 ;; Op2 ;; Ops) by MintBurns
     ==Int S' +Int MintBurns(Ops' ;; Ops) by Ops'
</code></pre>
<h4 id="removeliquidity">RemoveLiquidity</h4>
<pre class="language-text"><code>claim [inv-remove-liquidity]:
&lt;operations&gt;  ( [ Transaction Sender DEXTER Amount RemoveLiquidity(To, LqtBurned, _, _, _) ] #as Op =&gt; Ops' ) ;; Ops &lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X')   &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T =&gt; T'    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L =&gt; L'    &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B =&gt; B')   &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D =&gt; D'    &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S =&gt; S'    &lt;/lqt.totalSupply&gt;
requires 0 &lt;Int X  andBool X  ==Int B  +Int Sends(Op ;; Ops)
 andBool 0 &lt;Int T  andBool T  &lt;=Int D  +Int Transfers(Op ;; Ops)
 andBool 0 &lt;Int L  andBool L  ==Int S  +Int MintBurns(Op ;; Ops)
ensures  0 &lt;Int X' andBool X' ==Int B' +Int Sends(Ops' ;; Ops)
 andBool 0 &lt;Int T' andBool T' &lt;=Int D' +Int Transfers(Ops' ;; Ops)
 andBool 0 &lt;Int L' andBool L' ==Int S' +Int MintBurns(Ops' ;; Ops)

proof [inv-remove-liquidity]:
- apply [remove-liquidity]
  - Amount ==Int 0 by assert
  - LqtBurned &lt;Int L by assert
- unify RHS
  - Ops' == ( [ Transaction DEXTER LQT   0            MintOrBurn(Sender, LqtBurned) ] #as Op1 )
         ;; ( [ Transaction DEXTER TOKEN 0            Transfer(DEXTER, To, TokensWithdrawn) ] #as Op2 )
         ;; ( [ Transaction DEXTER To    XtzWithdrawn Default() ] #as Op3 )
  - X' == X -Int ( LqtBurned *Int X /Int L #as XtzWithdrawn )
  - T' == T -Int ( LqtBurned *Int T /Int L #as TokensWithdrawn )
  - L' == L -Int LqtBurned
  - B' == B
  - D' == D
  - S' == S
- X' &gt;Int 0 by X &gt;Int 0 and LqtBurned &lt;Int L
- T' &gt;Int 0 by T &gt;Int 0 and LqtBurned &lt;Int L
- L' &gt;Int 0 by LqtBurned &lt;Int L
- X' ==Int X -Int XtzWithdrawn
     ==Int B +Int Sends(Op ;; Ops) -Int XtzWithdrawn by premise
     ==Int B' +Int Sends(Op ;; Ops) -Int XtzWithdrawn by B'
     ==Int B' +Int Sends(Ops) -Int XtzWithdrawn by Sends and Amount ==Int 0
     ==Int B' +Int Sends(Op3 ;; Ops) by Sends
     ==Int B' +Int Sends(Op2 ;; Op3 ;; Ops) by Sends
     ==Int B' +Int Sends(Op1 ;; Op2 ;; Op3 ;; Ops) by Sends
     ==Int B' +Int Sends(Ops' ;; Ops) by Ops'
- T' ==Int T -Int TokensWithdrawn
     &lt;=Int D +Int Transfers(Op ;; Ops) -Int TokensWithdrawn by premise
     ==Int D' +Int Transfers(Op ;; Ops) -Int TokensWithdrawn by D'
     ==Int D' +Int Transfers(Ops) -Int TokensWithdrawn by Transfers
     ==Int D' +Int Transfers(Op3 ;; Ops) -Int TokensWithdrawn by Transfers
     ==Int D' +Int Transfers(Op2 ;; Op3 ;; Ops) by Transfers
     ==Int D' +Int Transfers(Op1 ;; Op2 ;; Op3 ;; Ops) by Transfers
     ==Int D' +Int Transfers(Ops' ;; Ops) by Ops'
- L' ==Int L -Int LqtBurned
     ==Int S +Int MintBurns(Op ;; Ops) -Int LqtBurned by premise
     ==Int S' +Int MintBurns(Op ;; Ops) -Int LqtBurned by S'
     ==Int S' +Int MintBurns(Ops) -Int LqtBurned by MintBurns
     ==Int S' +Int MintBurns(Op3 ;; Ops) -Int LqtBurned by MintBurns
     ==Int S' +Int MintBurns(Op2 ;; Op3 ;; Ops) -Int LqtBurned by MintBurns
     ==Int S' +Int MintBurns(Op1 ;; Op2 ;; Op3 ;; Ops) by MintBurns
     ==Int S' +Int MintBurns(Ops' ;; Ops) by Ops'
</code></pre>
<h4 id="xtztotoken">XtzToToken</h4>
<pre class="language-text"><code>claim [inv-xtz-to-token]:
&lt;operations&gt;  ( [ Transaction Sender DEXTER XtzSold XtzToToken(To, _, _) ] #as Op =&gt; Ops' ) ;; Ops &lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X')   &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T =&gt; T'    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L =&gt; L'    &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B =&gt; B')   &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D =&gt; D'    &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S =&gt; S'    &lt;/lqt.totalSupply&gt;
requires 0 &lt;Int X  andBool X  ==Int B  +Int Sends(Op ;; Ops)
 andBool 0 &lt;Int T  andBool T  &lt;=Int D  +Int Transfers(Op ;; Ops)
 andBool 0 &lt;Int L  andBool L  ==Int S  +Int MintBurns(Op ;; Ops)
ensures  0 &lt;Int X' andBool X' ==Int B' +Int Sends(Ops' ;; Ops)
 andBool 0 &lt;Int T' andBool T' &lt;=Int D' +Int Transfers(Ops' ;; Ops)
 andBool 0 &lt;Int L' andBool L' ==Int S' +Int MintBurns(Ops' ;; Ops)

proof [inv-xtz-to-token]:
- let XtzSoldNetBurn = XtzSold *Int 999 /Int 1000
      TokensBought   = 999 *Int XtzSoldNetBurn *Int T /Int (1000 *Int X +Int 999 *Int XtzSoldNetBurn)
- apply [xtz-to-token]
- unify RHS
  - Ops' == ( [ Transaction DEXTER TOKEN 0                           Transfer(DEXTER, To, TokensBought) ] #as Op1 )
         ;; ( [ Transaction DEXTER Null  XtzSold -Int XtzSoldNetBurn Default ] #as Op2 )
  - X' == X +Int XtzSoldNetBurn
  - T' == T -Int TokensBought
  - L' == L
  - B' == #if Sender &lt;&gt; Dexter #then B +Int XtzSold #else B #fi
  - D' == D
  - S' == S
- X' &gt;Int 0 by X &gt;Int 0 and XtzSoldNetBurn &gt;=Int 0
- TokensBought &lt;Int T by simp
- T' &gt;Int 0 by TokensBought &lt;Int T
- L' &gt;Int 0 by L &gt;Int 0
- split Sender
  - case Sender &lt;&gt; DEXTER
    - X' ==Int X +Int XtzSoldNetBurn
         ==Int B +Int Sends(Op ;; Ops) +Int XtzSoldNetBurn by premise
         ==Int B +Int Sends(Ops) +Int XtzSoldNetBurn by Sends
         ==Int B' -Int XtzSold +Int Sends(Ops) +Int XtzSoldNetBurn by B'
         ==Int B' +Int Sends(Op2 ;; Ops) by Sends
         ==Int B' +Int Sends(Op1 ;; Op2 ;; Ops) by Sends
         ==Int B' +Int Sends(Ops' ;; Ops) by Ops'
  - case Sender == DEXTER
    - X' ==Int X +Int XtzSoldNetBurn
         ==Int B +Int Sends(Op ;; Ops) +Int XtzSoldNetBurn by premise
         ==Int B +Int Sends(Ops) -Int XtzSold +Int XtzSoldNetBurn by Sends
         ==Int B' +Int Sends(Ops) -Int XtzSold +Int XtzSoldNetBurn by B'
         ==Int B' +Int Sends(Op2 ;; Ops) by Sends
         ==Int B' +Int Sends(Op1 ;; Op2 ;; Ops) by Sends
         ==Int B' +Int Sends(Ops' ;; Ops) by Ops'
- T' ==Int T -Int TokensBought
     &lt;=Int D +Int Transfers(Op ;; Ops) -Int TokensBought by premise
     ==Int D' +Int Transfers(Op ;; Ops) -Int TokensBought by D'
     ==Int D' +Int Transfers(Ops) -Int TokensBought by Transfers
     ==Int D' +Int Transfers(Ops' ;; Ops) by Transfers
- L' ==Int L
     ==Int S +Int MintBurns(Op ;; Ops) by premise
     ==Int S' +Int MintBurns(Op ;; Ops) by S'
     ==Int S' +Int MintBurns(Ops) by MintBurns
     ==Int S' +Int MintBurns(Ops' ;; Ops) by MintBurns
</code></pre>
<h4 id="tokentoxtz">TokenToXtz</h4>
<pre class="language-text"><code>claim [inv-token-to-xtz]:
&lt;operations&gt;  ( [ Transaction Sender DEXTER Amount TokenToXtz(To, TokensSold, _, _) ] #as Op =&gt; Ops' ) ;; Ops &lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X')   &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T =&gt; T'    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L =&gt; L'    &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B =&gt; B')   &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D =&gt; D'    &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S =&gt; S'    &lt;/lqt.totalSupply&gt;
requires 0 &lt;Int X  andBool X  ==Int B  +Int Sends(Op ;; Ops)
 andBool 0 &lt;Int T  andBool T  &lt;=Int D  +Int Transfers(Op ;; Ops)
 andBool 0 &lt;Int L  andBool L  ==Int S  +Int MintBurns(Op ;; Ops)
ensures  0 &lt;Int X' andBool X' ==Int B' +Int Sends(Ops' ;; Ops)
 andBool 0 &lt;Int T' andBool T' &lt;=Int D' +Int Transfers(Ops' ;; Ops)
 andBool 0 &lt;Int L' andBool L' ==Int S' +Int MintBurns(Ops' ;; Ops)

proof [inv-token-to-xtz]:
- let XtzBought        = 999 *Int TokensSold *Int X /Int (1000 *Int T +Int 999 *Int TokensSold)
      XtzBoughtNetBurn = XtzBought * 999 / 1000
- Sender =/=K DEXTER by [sender-is-not-dexter]
- apply [token-to-xtz]
  - Amount ==Int 0 by assert
- unify RHS
  - Ops' == ( [ Transaction DEXTER TOKEN 0                            Transfer(Sender, DEXTER, TokensSold) ] #as Op1 )
         ;; ( [ Transaction DEXTER To    XtzBoughtNetBurn             Default() ] #as Op2 )
         ;; ( [ Transaction DEXTER NULL  XtzBought - XtzBoughtNetBurn Default() ] #as Op3 )
  - X' == X -Int XtzBought
  - T' == T +Int TokensSold
  - L' == L
  - B' == B
  - D' == D
  - S' == S
- XtzBought &lt;Int X by simp
- X' &gt;Int 0 by XtzBought &lt;Int X
- T' &gt;Int 0 by T &gt;Int 0 and TokensSold &gt;=Int 0
- L' &gt;Int 0 by L &gt;Int 0
- X' ==Int X -Int XtzBought
     ==Int B +Int Sends(Op ;; Ops) -Int XtzBought by premise
     ==Int B' +Int Sends(Op ;; Ops) -Int XtzBought by B'
     ==Int B' +Int Sends(Ops) -Int XtzBought by Sends and Amount ==Int 0
     ==Int B' +Int Sends(Op3 ;; Ops) -Int XtzBoughtNetBurn  by Sends
     ==Int B' +Int Sends(Op2 ;; Op3 ;; Ops) by Sends
     ==Int B' +Int Sends(Op1 ;; Op2 ;; Op3 ;; Ops) by Sends
     ==Int B' +Int Sends(Ops' ;; Ops) by Ops'
- T' ==Int T +Int TokensSold
     &lt;=Int D +Int Transfers(Op ;; Ops) +Int TokensSold by premise
     ==Int D' +Int Transfers(Op ;; Ops) +Int TokensSold by D'
     ==Int D' +Int Transfers(Ops) +Int TokensSold by Transfers
     ==Int D' +Int Transfers(Op3 ;; Ops) +Int TokensSold by Transfers
     ==Int D' +Int Transfers(Op2 ;; Op3 ;; Ops) +Int TokensSold by Transfers
     ==Int D' +Int Transfers(Op1 ;; Op2 ;; Op3 ;; Ops) by Transfers and Sender =/=K DEXTER
     ==Int D' +Int Transfers(Ops' ;; Ops) by Ops'
- L' ==Int L
     ==Int S +Int MintBurns(Op ;; Ops) by premise
     ==Int S' +Int MintBurns(Op ;; Ops) by S'
     ==Int S' +Int MintBurns(Ops) by MintBurns
     ==Int S' +Int MintBurns(Op3 ;; Ops) by MintBurns
     ==Int S' +Int MintBurns(Op2 ;; Op3 ;; Ops) by MintBurns
     ==Int S' +Int MintBurns(Op1 ;; Op2 ;; Op3 ;; Ops) by MintBurns
     ==Int S' +Int MintBurns(Ops' ;; Ops) by Ops'
</code></pre>
<h4 id="tokentotoken">TokenToToken</h4>
<pre class="language-text"><code>claim [inv-token-to-token]:
&lt;operations&gt;
   ( [ Transaction Sender DEXTER Amount TokenToToken(OutputDexter, MinTokensBought, To, TokensSold, Deadline) ] #as Op ) ;; Ops
=&gt;
   Ops' ;; Ops
&lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X')   &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T =&gt; T'    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L =&gt; L'    &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B =&gt; B')   &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D =&gt; D'    &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S =&gt; S'    &lt;/lqt.totalSupply&gt;
requires 0 &lt;Int X  andBool X  ==Int B  +Int Sends(Op ;; Ops)
 andBool 0 &lt;Int T  andBool T  &lt;=Int D  +Int Transfers(Op ;; Ops)
 andBool 0 &lt;Int L  andBool L  ==Int S  +Int MintBurns(Op ;; Ops)
ensures  0 &lt;Int X' andBool X' ==Int B' +Int Sends(Ops' ;; Ops)
 andBool 0 &lt;Int T' andBool T' &lt;=Int D' +Int Transfers(Ops' ;; Ops)
 andBool 0 &lt;Int L' andBool L' ==Int S' +Int MintBurns(Ops' ;; Ops)

proof [inv-token-to-token]:
- let XtzBought        = 999 *Int TokensSold *Int X /Int (1000 *Int T +Int 999 *Int TokensSold)
      XtzBoughtNetBurn = XtzBought * 999 / 1000
- Sender =/=K DEXTER by [sender-is-not-dexter]
- apply [token-to-token]
  - Amount ==Int 0 by assert
- unify RHS
  - Ops' == ( [ Transaction DEXTER TOKEN        0                            Transfer(Sender, DEXTER, TokensSold) ] #as Op1 )
         ;; ( [ Transaction DEXTER OutputDexter XtzBoughtNetBurn             XtzToToken(To, MinTokensBought, Deadline) ] #as Op2 )
         ;; ( [ Transaction DEXTER NULL         XtzBought - XtzBoughtNetBurn Default() ] #as Op3 )
  - X' == X -Int XtzBought
  - T' == T +Int TokensSold
  - L' == L
  - B' == B
  - D' == D
  - S' == S
- XtzBought &lt;Int X by simp
- X' &gt;Int 0 by XtzBought &lt;Int X
- T' &gt;Int 0 by T &gt;Int 0 and TokensSold &gt;=Int 0
- L' &gt;Int 0 by L &gt;Int 0
- X' ==Int X -Int XtzBought
     ==Int B +Int Sends(Op ;; Ops) -Int XtzBought by premise
     ==Int B' +Int Sends(Op ;; Ops) -Int XtzBought by B'
     ==Int B' +Int Sends(Ops) -Int XtzBought by Sends and Amount ==Int 0
     ==Int B' +Int Sends(Op3 ;; Ops) -Int XtzBoughtNetBurn  by Sends
     ==Int B' +Int Sends(Op2 ;; Op3 ;; Ops) by Sends
     ==Int B' +Int Sends(Op1 ;; Op2 ;; Op3 ;; Ops) by Sends
     ==Int B' +Int Sends(Ops' ;; Ops) by Ops'
- T' ==Int T +Int TokensSold
     &lt;=Int D +Int Transfers(Op ;; Ops) +Int TokensSold by premise
     ==Int D' +Int Transfers(Op ;; Ops) +Int TokensSold by D'
     ==Int D' +Int Transfers(Ops) +Int TokensSold by Transfers
     ==Int D' +Int Transfers(Op3 ;; Ops) +Int TokensSold by Transfers
     ==Int D' +Int Transfers(Op2 ;; Op3 ;; Ops) +Int TokensSold by Transfers
     ==Int D' +Int Transfers(Op1 ;; Op2 ;; Op3 ;; Ops) by Transfers and Sender =/=K DEXTER
     ==Int D' +Int Transfers(Ops' ;; Ops) by Ops'
- L' ==Int L
     ==Int S +Int MintBurns(Op ;; Ops) by premise
     ==Int S' +Int MintBurns(Op ;; Ops) by S'
     ==Int S' +Int MintBurns(Ops) by MintBurns
     ==Int S' +Int MintBurns(Op3 ;; Ops) by MintBurns
     ==Int S' +Int MintBurns(Op2 ;; Op3 ;; Ops) by MintBurns
     ==Int S' +Int MintBurns(Op1 ;; Op2 ;; Op3 ;; Ops) by MintBurns
     ==Int S' +Int MintBurns(Ops' ;; Ops) by Ops'
</code></pre>
<h4 id="default">Default</h4>
<pre class="language-text"><code>claim [inv-default]:
&lt;operations&gt;  ( [ Transaction Sender DEXTER Amount Default() ] #as Op =&gt; Ops' ) ;; Ops &lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X')   &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T =&gt; T'    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L =&gt; L'    &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B =&gt; B')   &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D =&gt; D'    &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S =&gt; S'    &lt;/lqt.totalSupply&gt;
requires 0 &lt;Int X  andBool X  ==Int B  +Int Sends(Op ;; Ops)
 andBool 0 &lt;Int T  andBool T  &lt;=Int D  +Int Transfers(Op ;; Ops)
 andBool 0 &lt;Int L  andBool L  ==Int S  +Int MintBurns(Op ;; Ops)
ensures  0 &lt;Int X' andBool X' ==Int B' +Int Sends(Ops' ;; Ops)
 andBool 0 &lt;Int T' andBool T' &lt;=Int D' +Int Transfers(Ops' ;; Ops)
 andBool 0 &lt;Int L' andBool L' ==Int S' +Int MintBurns(Ops' ;; Ops)

proof [inv-default]:
- apply [default]
- unify RHS
  - Ops' == .List
  - X' == X +Int Amount
  - T' == T
  - L' == L
  - D' == D
  - S' == S
- X' &gt;Int 0 by X &gt;Int 0 and Amount &gt;=Int 0
- T' &gt;Int 0 by T &gt;Int 0
- L' &gt;Int 0 by L &gt;Int 0
- split Sender
  - case Sender &lt;&gt; DEXTER
    - X' ==Int X +Int Amount
         ==Int B +Int Sends(Op ;; Ops) +Int Amount by premise
         ==Int B' +Int Sends(Op ;; Ops) by B'
         ==Int B' +Int Sends(Ops) by Sends
         ==Int B' +Int Sends(Ops' ;; Ops) by Ops'
  - case Sender == DEXTER
    - X' ==Int X +Int Amount
         ==Int B +Int Sends(Op ;; Ops) +Int Amount by premise
         ==Int B' +Int Sends(Op ;; Ops) +Int Amount by B'
         ==Int B' +Int (Sends(Ops) -Int Amount) +Int Amount by Sends
         ==Int B' +Int Sends(Ops) by simp
         ==Int B' +Int Sends(Ops' ;; Ops) by Ops'
- T' ==Int T
     &lt;=Int D +Int Transfers(Op ;; Ops) by premise
     ==Int D' +Int Transfers(Op ;; Ops) by D'
     ==Int D' +Int Transfers(Ops) by Transfers
     ==Int D' +Int Transfers(Ops' ;; Ops) by Ops'
- L' ==Int L
     ==Int S +Int MintBurns(Op ;; Ops) by premise
     ==Int S' +Int MintBurns(Op ;; Ops) by S'
     ==Int S' +Int MintBurns(Ops) by MintBurns
     ==Int S' +Int MintBurns(Ops' ;; Ops) by Ops'
</code></pre>
<h3 id="proof-for-external-contract-calls">Proof for External Contract Calls</h3>
<p>We prove the claim <code>[inv]</code> for any external contract calls from Dexter.</p>
<p>Since external contracts are unknown and arbitrary, we need to make certain assumptions on the behavior of external contracts that are required for the functional correctness and security of the Dexter contract.  The specific assumptions we made are presented later in this document.  The invariant proof is based on the assumptions, and it is important to independently verify that the token and liquidity contract implementations satisfy the assumptions.</p>
<p>There exist different types of external calls made by Dexter as follows:</p>
<ul>
<li>Simply send XTZ to others</li>
<li>Call another Dexter contract's XtzToToken()</li>
<li>Call the token contract's Transfer()</li>
<li>Call the liquidity contract's MintOrBurn()</li>
</ul>
<h4 id="xtz-transfers">XTZ Transfers</h4>
<p>The following claim formulates the invariant for the first two types of external calls.</p>
<pre class="language-text"><code>claim [inv-send]:
&lt;operations&gt;  ( [ Transaction DEXTER Target Amount CallParams ] #as Op =&gt; Ops' ) ;; Ops &lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X')   &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T =&gt; T'    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L =&gt; L'    &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B =&gt; B')   &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D =&gt; D'    &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S =&gt; S'    &lt;/lqt.totalSupply&gt;
requires Target =/=K DEXTER
 andBool ( CallParams ==K Default() orBool CallParams ==K (XtzToToken _) )
requires 0 &lt;Int X  andBool X  ==Int B  +Int Sends(Op ;; Ops)
 andBool 0 &lt;Int T  andBool T  &lt;=Int D  +Int Transfers(Op ;; Ops)
 andBool 0 &lt;Int L  andBool L  ==Int S  +Int MintBurns(Op ;; Ops)
ensures  0 &lt;Int X' andBool X' ==Int B' +Int Sends(Ops' ;; Ops)
 andBool 0 &lt;Int T' andBool T' &lt;=Int D' +Int Transfers(Ops' ;; Ops)
 andBool 0 &lt;Int L' andBool L' ==Int S' +Int MintBurns(Ops' ;; Ops)

proof [inv-send]:
- apply [send]
- unify RHS
  - X' == X
  - T' == T
  - L' == L
  - B' == B -Int Amount
  - D' == D
  - S' == S
- X' &gt;Int 0 by X &gt;Int 0
- T' &gt;Int 0 by T &gt;Int 0
- L' &gt;Int 0 by L &gt;Int 0
- X' ==Int X
     ==Int B +Int Sends(Op ;; Ops) by premise
     ==Int (B' +Int Amount) +Int Sends(Op ;; Ops) by B'
     ==Int (B' +Int Amount) +Int (Sends(Ops) -Int Amount) by Sends
     ==Int B' +Int Sends(Ops) by simp
     ==Int B' +Int Sends(Ops' ;; Ops) by Ops' and [only-dexter]
- T' ==Int T
     &lt;=Int D +Int Transfers(Op ;; Ops) by premise
     ==Int D' +Int Transfers(Op ;; Ops) by D'
     ==Int D' +Int Transfers(Ops) by Transfers
     ==Int D' +Int Transfers(Ops' ;; Ops) by Ops' and [only-dexter]
- L' ==Int L
     ==Int S +Int MintBurns(Op ;; Ops) by premise
     ==Int S' +Int MintBurns(Op ;; Ops) by S'
     ==Int S' +Int MintBurns(Ops) by MintBurns
     ==Int S' +Int MintBurns(Ops' ;; Ops) by Ops' and [only-dexter]
</code></pre>
<h4 id="token-transfers">Token Transfers</h4>
<p>The following claim is for the token contract call Transfer().</p>
<pre class="language-text"><code>claim [inv-token-transfer]:
&lt;operations&gt;  ( [ Transaction _ TOKEN Amount Transfer(From, To, Value) ] #as Op =&gt; Ops' ) ;; Ops &lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X')   &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T =&gt; T'    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L =&gt; L'    &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B =&gt; B')   &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D =&gt; D'    &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S =&gt; S'    &lt;/lqt.totalSupply&gt;
requires 0 &lt;Int X  andBool X  ==Int B  +Int Sends(Op ;; Ops)
 andBool 0 &lt;Int T  andBool T  &lt;=Int D  +Int Transfers(Op ;; Ops)
 andBool 0 &lt;Int L  andBool L  ==Int S  +Int MintBurns(Op ;; Ops)
ensures  0 &lt;Int X' andBool X' ==Int B' +Int Sends(Ops' ;; Ops)
 andBool 0 &lt;Int T' andBool T' &lt;=Int D' +Int Transfers(Ops' ;; Ops)
 andBool 0 &lt;Int L' andBool L' ==Int S' +Int MintBurns(Ops' ;; Ops)

proof [inv-token-transfer]:
- apply [token-transfer]
  - Amount ==Int 0 by assert
- unify RHS
  - X' == X
  - T' == T
  - L' == L
  - B' == B
  - D' == #if     From == DEXTER and To &lt;&gt; DEXTER #then D -Int Value
          #elseif From &lt;&gt; DEXTER and To == DEXTER #then D +Int Value
          #else                                         D
          #fi
  - S' == S
- X' &gt;Int 0 by X &gt;Int 0
- T' &gt;Int 0 by T &gt;Int 0
- L' &gt;Int 0 by L &gt;Int 0
- X' ==Int X
     ==Int B +Int Sends(Op ;; Ops) by premise
     ==Int B' +Int Sends(Op ;; Ops) by B'
     ==Int B' +Int Sends(Ops) by Sends and Amount ==Int 0
     ==Int B' +Int Sends(Ops' ;; Ops) by Ops' and [only-dexter]
- L' ==Int L
     ==Int S +Int MintBurns(Op ;; Ops) by premise
     ==Int S' +Int MintBurns(Op ;; Ops) by S'
     ==Int S' +Int MintBurns(Ops) by MintBurns
     ==Int S' +Int MintBurns(Ops' ;; Ops) by Ops' and [only-dexter]
- split From, To
  - case From == DEXTER and To &lt;&gt; DEXTER
    - T' ==Int T
         &lt;=Int D +Int Transfers(Op ;; Ops) by premise
         ==Int (D' +Int Value) +Int Transfers(Op ;; Ops) by D'
         ==Int (D' +Int Value) +Int (Transfers(Ops) -Int Value) by Transfers
         ==Int D' +Int Transfers(Ops) by simp
         ==Int D' +Int Transfers(Ops' ;; Ops) by Ops' and [only-dexter]
  - case From &lt;&gt; DEXTER and To == DEXTER
    - T' ==Int T
         &lt;=Int D +Int Transfers(Op ;; Ops) by premise
         ==Int (D' -Int Value) +Int Transfers(Op ;; Ops) by D'
         ==Int (D' -Int Value) +Int (Transfers(Ops) +Int Value) by Transfers
         ==Int D' +Int Transfers(Ops) by simp
         ==Int D' +Int Transfers(Ops' ;; Ops) by Ops' and [only-dexter]
  - case From == DEXTER and To == DEXTER
    - T' ==Int T
         &lt;=Int D +Int Transfers(Op ;; Ops) by premise
         ==Int D' +Int Transfers(Op ;; Ops) by D'
         ==Int D' +Int (Transfers(Ops) -Int Value) by Transfers
         &lt;=Int D' +Int Transfers(Ops) by simp
         ==Int D' +Int Transfers(Ops' ;; Ops) by Ops' and [only-dexter]
  - case From &lt;&gt; DEXTER and To &lt;&gt; DEXTER
    - T' ==Int T
         &lt;=Int D +Int Transfers(Op ;; Ops) by premise
         ==Int D' +Int Transfers(Op ;; Ops) by D'
         ==Int D' +Int Transfers(Ops) by Transfers
         ==Int D' +Int Transfers(Ops' ;; Ops) by Ops' and [only-dexter]
</code></pre>
<h4 id="liquidity-mints-and-burns">Liquidity Mints and Burns</h4>
<p>The following claim is for the liquidity token contract call MintorBurn().</p>
<pre class="language-text"><code>claim [inv-lqt-mint-burn]:
&lt;operations&gt;  ( [ Transaction Sender LQT Amount MintOrBurn(_, Value) ] #as Op =&gt; .List ) ;; Ops &lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X')   &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T =&gt; T'    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L =&gt; L'    &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B =&gt; B')   &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D =&gt; D'    &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S =&gt; S'    &lt;/lqt.totalSupply&gt;
requires 0 &lt;Int X  andBool X  ==Int B  +Int Sends(Op ;; Ops)
 andBool 0 &lt;Int T  andBool T  &lt;=Int D  +Int Transfers(Op ;; Ops)
 andBool 0 &lt;Int L  andBool L  ==Int S  +Int MintBurns(Op ;; Ops)
ensures  0 &lt;Int X' andBool X' ==Int B' +Int Sends(Ops' ;; Ops)
 andBool 0 &lt;Int T' andBool T' &lt;=Int D' +Int Transfers(Ops' ;; Ops)
 andBool 0 &lt;Int L' andBool L' ==Int S' +Int MintBurns(Ops' ;; Ops)

proof [inv-lqt-mint-burn]:
- apply [lqt-mint-burn]
  - Sender ==K DEXTER by assert
  - Amount ==Int 0 by assert
- unify RHS
  - X' == X
  - T' == T
  - L' == L
  - B' == B
  - D' == D
  - S' == S +Int Value
- X' &gt;Int 0 by X &gt;Int 0
- T' &gt;Int 0 by T &gt;Int 0
- L' &gt;Int 0 by L &gt;Int 0
- X' ==Int X
     ==Int B +Int Sends(Op ;; Ops) by premise
     ==Int B' +Int Sends(Op ;; Ops) by B'
     ==Int B' +Int Sends(Ops) by Sends and Amount ==Int 0
- T' ==Int T
     &lt;=Int D +Int Transfers(Op ;; Ops) by premise
     ==Int D' +Int Transfers(Op ;; Ops) by D'
     ==Int D' +Int Transfers(Ops) by Transfers
- L' ==Int L
     ==Int S +Int MintBurns(Op ;; Ops) by premise
     ==Int (S' -Int Value) +Int MintBurns(Op ;; Ops) by S'
     ==Int (S' -Int Value) +Int (MintBurns(Ops) +Int Value) by MintBurns
     ==Int S' +Int MintBurns(Ops) by simp
</code></pre>
<h3 id="abstract-behaviors-of-dexter-entrypoints">Abstract Behaviors of Dexter Entrypoints</h3>
<p>We formulate the behavior of each Dexter entrypoint over an abstract configuration.  This formulation over the abstract configuration has been refined to the concrete configuration of the Michelson semantics, and then verified against the compiled bytecode of Dexter using the K framework.  The soundness of the refinement, which is currently in our trust base, allows us to conclude that the proved properties also hold for the Dexter bytecode.</p>
<h4 id="abstract-configuration">Abstract Configuration</h4>
<p>The abstract configuration consists of the following components (called "cells" in the K framework):</p>
<ul>
<li><code>&lt;operations&gt;</code>: the sequence of operations to be executed</li>
<li><code>&lt;xtzPool&gt;</code>: the XtzPool state variable</li>
<li><code>&lt;tokenPool&gt;</code>: the TokenPool state variable</li>
<li><code>&lt;lqtTotal&gt;</code>: the LqtTotal state variable</li>
<li><code>&lt;dexter.balance&gt;</code>: the XTZ balance of Dexter</li>
<li><code>&lt;tokenDexter&gt;</code>: the token balance of Dexter (stored in the token contract storage)</li>
<li><code>&lt;lqt.totalSupply&gt;</code>: the total liquidity supply (stored in the liquidity contract storage)</li>
<li><code>&lt;sourceaddr&gt;</code>: the source of the current operation</li>
<li><code>&lt;manager&gt;</code>: the manager account address</li>
<li><code>&lt;lqtAddress&gt;</code>: the liquidity contract address</li>
<li><code>&lt;freezeBaker&gt;</code>: the FreezeBaker lock</li>
<li><code>&lt;mynow&gt;</code>: the current timestamp</li>
</ul>
<p>Note that both <code>&lt;xtzPool&gt;</code> and <code>&lt;dexter.balance&gt;</code> are of the XTZ currency type, ranging from 0 to <code>2^64 - 1</code>.  Throughout this document, we implicitly assume that they are <em>defined</em> only when their values are within the valid range, otherwise they are undefined, meaning that any execution involving undefined currency values will fail or revert.</p>
<h4 id="constants-and-macros">Constants and Macros</h4>
<pre class="language-text"><code>syntax Address ::= DEXTER [constant]

syntax Address ::= TOKEN [constant]

syntax Address ::= LQT [macro]
rule [[ LQT =&gt; Lqt ]] &lt;lqtAddress&gt; Lqt &lt;/lqtAddress&gt;
</code></pre>
<pre class="language-text"><code>syntax Bool ::= IS_VALID(Int) [macro]
rule [is-valid]:
[[ IS_VALID(Deadline) =&gt; Now &lt;Int Deadline ]]
&lt;mynow&gt; #Timestamp(Now) &lt;/mynow&gt;
</code></pre>
<h4 id="addliquidity-1">AddLiquidity</h4>
<p>The following rule formulates the behaviors of the AddLiquidity() entrypoint.  It states that, when it succeeds, the entrypoint execution updates the three state variables and the XTZ balance of Dexter.  The execution succeeds when the <code>assert</code> conditions are satisfied, and fails otherwise.</p>
<pre class="language-text"><code>rule [add-liquidity]:
&lt;operations&gt;  ( [ Transaction Sender DEXTER XtzDeposited AddLiquidity(Owner, MinLqtMinted, MaxTokensDeposited, Deadline) ]
             =&gt; OpsEmitted
              ) ;; _
&lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X +Int XtzDeposited)      &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T =&gt; T +Int TokensDeposited    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L =&gt; L +Int LqtMinted          &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B =&gt; B')                       &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D                              &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S                              &lt;/lqt.totalSupply&gt;
assert   IS_VALID(Deadline)
 andBool TokensDeposited &lt;=Int MaxTokensDeposited
 andBool LqtMinted       &gt;=Int MinLqtMinted
ensures  TokensDeposited ==Int XtzDeposited *Int T up/Int X
 andBool LqtMinted       ==Int XtzDeposited *Int L   /Int X
 andBool OpsEmitted ==K [ Transaction DEXTER TOKEN 0 Transfer(Sender, DEXTER, TokensDeposited) ]
                     ;; [ Transaction DEXTER LQT   0 MintOrBurn(Owner, LqtMinted) ]
 andBool Sender =/=K DEXTER impliesBool B' ==Int B +Int XtzDeposited
 andBool Sender  ==K DEXTER impliesBool B' ==Int B
</code></pre>
<h4 id="removeliquidity-1">RemoveLiquidity</h4>
<p>The following rule formulates the behaviors of the RemoveLiquidity entrypoint.  As in the previous formulation, this specifies both success and failure cases depending on the satisfiability of the assertion conditions.</p>
<p>Note that the assertion explicitly includes the condition <code>LqtBurned &lt;Int L</code> that requires the liquidity amount to be burned should be <em>strictly</em> less than the total liquidity supply.  This condition is required for the functional correctness of Dexter, as already mentioned in the Dexter source code comment.  However, the current Dexter implementation does <em>not</em> check the condition, leaving the potential for Dexter becoming nonfunctional by mistake or corrupted admin users.  <em><strong>It is strongly recommended to add an explicit input validation for LqtBurned.</strong></em></p>
<pre class="language-text"><code>rule [remove-liquidity]:
&lt;operations&gt;  ( [ Transaction Sender DEXTER Amount RemoveLiquidity(To, LqtBurned, MinXtzWithdrawn, MinTokensWithdrawn, Deadline) ]
          =&gt; OpsEmitted ) ;; _
&lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X -Int XtzWithdrawn)      &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T =&gt; T -Int TokensWithdrawn    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L =&gt; L -Int LqtBurned          &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B)                             &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D                              &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S                              &lt;/lqt.totalSupply&gt;
assert   IS_VALID(Deadline)
 andBool Amount ==Int 0
 andBool LqtBurned &lt;Int L
 andBool XtzWithdrawn    &gt;=Int MinXtzWithdrawn
 andBool TokensWithdrawn &gt;=Int MinTokensWithdrawn
ensures  XtzWithdrawn    ==Int LqtBurned *Int X /Int L
 andBool TokensWithdrawn ==Int LqtBurned *Int T /Int L
 andBool OpsEmitted ==K [ Transaction DEXTER LQT   0            MintOrBurn(Sender, LqtBurned) ]
                     ;; [ Transaction DEXTER TOKEN 0            Transfer(DEXTER, To, TokensWithdrawn) ]
                     ;; [ Transaction DEXTER To    XtzWithdrawn Default() ]
</code></pre>
<h4 id="xtztotoken-1">XtzToToken</h4>
<pre class="language-text"><code>rule [xtz-to-token]:
&lt;operations&gt;  ( [ Transaction Sender DEXTER XtzSold XtzToToken(To, MinTokensBought, Deadline) ] =&gt; OpsEmitted )
           ;; _
&lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X +Int XtzSoldNetBurn) &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T =&gt; T -Int TokensBought    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L                           &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B =&gt; B')                    &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D                           &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S                           &lt;/lqt.totalSupply&gt;
assert   IS_VALID(Deadline)
 andBool TokensBought &gt;=Int MinTokensBought
ensures  XtzSoldNetBurn ==Int XtzSold *Int 999 /Int 1000
 andBool TokensBought ==Int 999 *Int XtzSoldNetBurn *Int T /Int (1000 *Int X +Int 999 *Int XtzSoldNetBurn)
 andBool OpsEmitted ==K [ Transaction DEXTER TOKEN 0                           Transfer(DEXTER, To, TokensBought) ]
                     ;; [ Transaction DEXTER NULL  XtzSold -Int XtzSoldNetBurn Default() ]
 andBool Sender =/=K DEXTER impliesBool B' ==Int B +Int XtzSold
 andBool Sender  ==K DEXTER impliesBool B' ==Int B
</code></pre>
<h4 id="tokentoxtz-1">TokenToXtz</h4>
<pre class="language-text"><code>rule [token-to-xtz]:
&lt;operations&gt;  ( [ Transaction Sender DEXTER Amount TokenToXtz(To, TokensSold, MinXtzBought, Deadline) ] =&gt; OpsEmitted )
          ;; _
&lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X -Int XtzBought)     &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T =&gt; T +Int TokensSold     &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L                          &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B)                         &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D                          &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S                          &lt;/lqt.totalSupply&gt;
assert   IS_VALID(Deadline)
 andBool Amount ==Int 0
 andBool XtzBought &gt;=Int MinXtzBought
ensures  XtzBought ==Int 999 *Int TokensSold *Int X /Int (1000 *Int T +Int 999 *Int TokensSold)
 andBool XtzBoughtNetBurn ==Int XtzBought *Int 999 /Int 1000
 andBool OpsEmitted ==K [ Transaction DEXTER TOKEN 0                            Transfer(Sender, DEXTER, TokensSold) ]
                     ;; [ Transaction DEXTER To    XtzBoughtNetBurn             Default() ]
                     ;; [ Transaction DEXTER NULL  XtzBought - XtzBoughtNetBurn Default() ]
</code></pre>
<h4 id="tokentotoken-1">TokenToToken</h4>
<p>Note that it is straightforward to prove the equivalence between the following two methods for the token-to-token exchange:</p>
<ul>
<li>Alice sends only a single transaction to Dexter:<br>
<code>transaction Alice DEXTER 0 TokenToToken(OutputDexterContract, MinTokensBought, To, TokensSold, Deadline)</code>.</li>
<li>Alice first sends a transaction to Dexter:<br>
<code>Transaction Alice DEXTER 0 TokenToXtz(Alice, TokensSold, 0, Deadline)</code>, and then immediately sends another transaction to OutputDexterContract, <code>Transaction Alice OutputDexterContract XtzBought XtzToToken(To, MinTokensBought, Deadline)</code>, where XtzBought is the amount she received from the first transaction, provided that no transactions have been made to OutputDexterContract between the two transactions.</li>
</ul>
<pre class="language-text"><code>rule [token-to-token]:
&lt;operations&gt;  ( [ Transaction Sender DEXTER Amount TokenToToken(OutputDexterContract, MinTokensBought, To, TokensSold, Deadline) ]
             =&gt; OpsEmitted ) ;; _
&lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X -Int XtzBought)     &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T =&gt; T +Int TokensSold     &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L                          &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B)                         &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D                          &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S                          &lt;/lqt.totalSupply&gt;
assert   IS_VALID(Deadline)
 andBool Amount ==Int 0
ensures  XtzBought ==Int 999 *Int TokensSold *Int X /Int (1000 *Int T +Int 999 *Int TokensSold)
 andBool XtzBoughtNetBurn ==Int XtzBought *Int 999 /Int 1000
 andBool OpsEmitted ==K [ Transaction DEXTER TOKEN 0  Transfer(Sender, DEXTER, TokensSold) ]
                     ;; [ Transaction DEXTER OutputDexterContract XtzBoughtNetBurn XtzToToken(To, MinTokensBought, Deadline) ]
                     ;; [ Transaction DEXTER NULL XtzBought - XtzBoughtNetBurn Default() ]
</code></pre>
<h4 id="default-1">Default</h4>
<pre class="language-text"><code>rule [default]:
&lt;operations&gt;  ( [ Transaction Sender DEXTER Amount Default() ] =&gt; .List ) ;; _ &lt;/operations&gt;
&lt;xtzPool&gt;        #Mutez(X =&gt; X +Int Amount)    &lt;/xtzPool&gt;
&lt;tokenPool&gt;             T                      &lt;/tokenPool&gt;
&lt;lqtTotal&gt;              L                      &lt;/lqtTotal&gt;
&lt;dexter.balance&gt; #Mutez(B =&gt; B')               &lt;/dexter.balance&gt;
&lt;tokenDexter&gt;           D                      &lt;/tokenDexter&gt;
&lt;lqt.totalSupply&gt;       S                      &lt;/lqt.totalSupply&gt;
ensures  Sender =/=K DEXTER impliesBool B' ==Int B +Int Amount
 andBool Sender  ==K DEXTER impliesBool B' ==Int B
</code></pre>
<h2 id="liquidity-share-value-security">Liquidity Share Value Security</h2>
<p>The property <code>[inv]</code> states the relationship between the Dexter state variables and the actual pool reserves and liquidity supply.  Now we formulate another property regarding the relationship over the Dexter state variables themselves.</p>
<p>Let XtzPool, TokenPool, and LqtTotal be the current value of the Dexter state variables.  Suppose that an operation updates the state variables to new values, say, XtzPool', TokenPool', and LqtTotal', respectively.  Then, for any (successful) execution of an arbitrary operation, we must have:</p>
<pre class="language-text"><code>  XtzPool' * TokenPool'        LqtTotal'
  ---------------------  &gt;=  ( -------- )^2
  XtzPool  * TokenPool         LqtTotal
</code></pre>
<p>where the division is the real arithmetic division (i.e., no rounding).</p>
<p>Note that the above property (together with the <code>[inv]</code> property) says that the liquidity share price (i.e., the multiplication of the amounts of XTZ and tokens to be redeemed per unit liquidity) <em>never</em> decreases.  Intuitively, this implies the following desired properties:</p>
<ul>
<li>When adding liquidity, users <em>cannot</em> mint more liquidity shares than they should.</li>
<li>When removing liquidity, users <em>cannot</em> redeem more assets than they should.</li>
<li>When exchanging tokens, users <em>cannot</em> receive more XTZ or tokens than they should.</li>
</ul>
<p>(Note that, however, this property has <em>nothing</em> to do with the <em>USD value</em> of the liquidity share.  Indeed, the USD value of the liquidity share could decrease due to the so-called "Impermanent Loss" problem.)</p>
<p>The following claim <code>[pool]</code> formulates the liquidity share price property.</p>
<pre class="language-text"><code>claim [pool]:
&lt;operations&gt; (Op =&gt; _) ;; _ &lt;/operations&gt;
&lt;xtzPool&gt;     #Mutez(X =&gt; X')   &lt;/xtzPool&gt;
&lt;tokenPool&gt;          T =&gt; T'    &lt;/tokenPool&gt;
&lt;lqtTotal&gt;           L =&gt; L'    &lt;/lqtTotal&gt;
requires X &gt;Int 0 andBool T &gt;Int 0 andBool L &gt;Int 0
ensures  (X' *Int T') /Real (X *Int T) &gt;=Real (L' /Real L) ^Real 2
</code></pre>
<pre class="language-text"><code>proof [pool]:
- let Op = Transaction _ Target Amount CallParams
- split Target
  - case Target == DEXTER
    - split CallParams
      - case CallParams == AddLiquidity _
        - apply [add-liquidity]
        - unify RHS
          - X' == X +Int XtzDeposited
          - T' == T +Int TokensDeposited
          - L' == L +Int LqtMinted
          - XtzDeposited    == Amount
          - TokensDeposited == XtzDeposited *Int T up/Int X
          - LqtMinted       == XtzDeposited *Int L   /Int X
        - let TokensDepositedReal = XtzDeposited *Int T /Real X
        - let LqtMintedReal       = XtzDeposited *Int L /Real X
        - TokensDeposited &gt;=Real TokensDepositedReal
        - LqtMinted       &lt;=Real LqtMintedReal
        - (X' *Int T') /Real (X *Int T)
             ==Real ((X +Int XtzDeposited) *Int  (T +Int  TokensDeposited    )) /Real (X *Int T) by X' and T'
             &gt;=Real ((X +Int XtzDeposited) *Real (T +Real TokensDepositedReal)) /Real (X *Int T)
                         by TokensDeposited &gt;=Real TokensDepositedReal
             ==Real (1 +Real XtzDeposited /Real X) *Real (1 +Real XtzDeposited /Real X) by simp(Real)
             ==Real (1 +Real XtzDeposited /Real X) ^Real 2 by simp(Real)
             ==Real ((L +Real LqtMintedReal) /Real L) ^Real 2 by simp(Real)
             &gt;=Real ((L +Real LqtMinted    ) /Real L) ^Real 2 by LqtMinted &lt;=Real LqtMintedReal
             ==Real (L' /Real L) ^Real 2 by L'
      - case CallParams == RemoveLiquidity(_, LqtBurned, _, _, _)
        - apply [remove-liquidity]
        - unify RHS
          - X' == X -Int XtzWithdrawn
          - T' == T -Int TokensWithdrawn
          - L' == L -Int LqtBurned
          - XtzWithdrawn    == LqtBurned *Int X /Int L
          - TokensWithdrawn == LqtBurned *Int T /Int L
        - let XtzWithdrawnReal    = LqtBurned *Int X /Real L
        - let TokensWithdrawnReal = LqtBurned *Int T /Real L
        - XtzWithdrawn    &lt;=Real XtzWithdrawnReal
        - TokensWithdrawn &lt;=Real TokensWithdrawnReal
        - (X' *Int T') /Real (X *Int T)
            ==Real ((X -Int  XtzWithdrawn    ) *Int  (T -Int  TokensWithdrawn    )) /Real (X *Int T) by X' and T'
            &gt;=Real ((X -Real XtzWithdrawnReal) *Real (T -Real TokensWithdrawnReal)) /Real (X *Int T)
                        by XtzWithdrawn &lt;=Real XtzWithdrawnReal and TokensWithdrawn &lt;=Real TokensWithdrawnReal
            ==Real (1 -Real LqtBurned /Real L) *Real (1 -Real LqtBurned /Real L) by simp(Real)
            ==Real (1 -Real LqtBurned /Real L) ^Real 2 by simp(Real)
            ==Real ((L -Real LqtBurned) /Real L) ^Real 2 by simp(Real)
            ==Real (L' /Real L) ^Real 2 by L'
      - case CallParams == XtzToToken _
        - apply [xtz-to-token]
        - unify RHS
          - X' == X +Int XtzSold
          - T' == T -Int TokensBought
          - L' == L
          - XtzSold == Amount
          - XtzSoldNetBurn == XtzSold *Int 999 /Int 1000
          - TokensBought == 999 *Int XtzSoldNetBurn *Int T /Int (1000 *Int X +Int 999 *Int XtzSoldNetBurn)
        - let XtzSoldNetBurnReal == XtzSold *Int 999 /Real 1000
              TokensBoughtReal = 999 *Real XtzSoldNetBurnReal *Real T /Real (1000 *Real X +Real 999 *Real XtzSoldNetBurnReal)
        - TokensBought &lt;=Real TokensBoughtReal
                    by monotonicity of the exchange rate function
                    and the fact that the integer-version is less than the real valued version
        - (X' *Int T') /Real (X *Int T)
            ==Real ((X +Int XtzSold) *Int  (T -Int  TokensBought    )) /Real (X *Int T) by X' and T'
            &gt;=Real ((X +Int XtzSold) *Real (T -Real TokensBoughtReal)) /Real (X *Int T) by TokensBought &lt;=Real TokensBoughtReal
            ==Real (X +Real XtzSold) /Real (X +Real 0.999 *Real XtzSold) by simp(Real)
            &gt;=Real 1 by simp(Real)
            ==Real (L' /Real L) ^Real 2 by L' == L
      - case CallParams == TokenToXtz(_, TokensSold, _, _) | CallParams == TokenToToken(_, _, _, TokensSold, _)
        - apply [token-to-xtz] or [token-to-token]
        - unify RHS
          - X' == X -Int XtzBought
          - T' == T +Int TokensSold
          - L' == L
          - XtzBought == 999 *Int TokensSold *Int X /Int (1000 *Int T +Int 999 *Int TokensSold)
        - let XtzBoughtReal = 999 *Int TokensSold *Int X /Real (1000 *Int T +Int 999 *Int TokensSold)
        - XtzBought &lt;=Real XtzBoughtReal
        - (X' *Int T') /Real (X *Int T)
            ==Real ((X -Int  XtzBought    ) *Int  (T +Int TokensSold)) /Real (X *Int T) by X' and T'
            &gt;=Real ((X -Real XtzBoughtReal) *Real (T +Int TokensSold)) /Real (X *Int T) by XtzBought &lt;=Real XtzBoughtReal
            ==Real (T +Real TokensSold) /Real (T +Real 0.999 *Real TokensSold) by simp(Real)
            &gt;=Real 1 by simp(Real)
            ==Real (L' /Real L) ^Real 2 by L' == L
      - case CallParams == Default _
        - apply [default]
        - unify RHS
          - X' == X +Int Amount
          - T' == T
          - L' == L
        - (X' *Int T') /Real (X *Int T) ==Real ((X +Int Amount) *Int T) /Real (X *Int T) by X' and T'
                                        &gt;=Real 1 by Amount &gt;=Int 0
                                        ==Real (L' /Real L) ^Real 2 by L' == L
  - case Target &lt;&gt; DEXTER
    - (X', T', L') == (X, T, L) by [only-dexter]
    - (X' *Int T') /Real (X *Int T) ==Real 1 by X' == X and T' == T
                                    ==Real (L' /Real L) ^Real 2 by L' == L
</code></pre>
<h2 id="operation-safety">Operation Safety</h2>
<p>In this section, we discuss the operation safety property a bit further.
Recall our definition of operation safety: all trades and liquidity redemptions/deposits have a bounded exchange rate and time in which they are applicable.
To see if this holds, we need only look at the five entrypoint specifications relating to these operations.
For convenience, we reiterate them below:</p>
<ul>
<li><code>AddLiquidity(owner, minLqtMinted, maxTokensDeposited, deadline)</code>: <code>amount -&gt; maxTokenDeposited, minLiquidityMinted</code></li>
<li><code>RemoveLiquidity(to, lqtBurned, minXtzWithdrawn, minTokensWithdrawn, deadline)</code>: <code>lqtBurned -&gt; minXtzWithdrawn, minTokensWithDrawn</code></li>
<li><code>XtzToToken(to, minTokensBought, deadline)</code>: <code>amount -&gt; minTokensBought</code></li>
<li><code>TokenToXtz(to, tokensSold, minXtzBought, deadline)</code>: <code>tokensSold -&gt; minXtzBought</code></li>
<li><code>TokenToToken(outputDexterContract, minTokensBought, to, tokensSold, deadline)</code>: <code>tokensSold -&gt; minTokensBought</code></li>
</ul>
<p>To see that each operation has a bounded time in which it is valid, it is enough to check that its functional spec asserts that its <em>deadline</em> has not passed; this is clearly the case.
To see that each operation has a bounded exchange rate in which it is valid, it is enough for each operation to specify the worst possible exchange rate the sender is willing to accept.
This is only slightly more complicated to show, because the kind of exchange depends on the entrypoint called.
Next to each entrypoint above, we used the notation <code>input -&gt; (min/max)bound1 [, (max/min)bound2]</code> (with the bracketed partial optional) which represents the input and worst-case bounds on the exchange rate.
The output prefix <code>min</code> describes the minimum amount a sender is willing to receive in exchange for sending assets.
The output prefix <code>max</code> describes the maximum amount a sender is required to <em>additionally</em> send in exchange for receiving assets.
All that remains to be done is correlate these output bounds with the actual movement of assets.
Recall that the LB system manages three kinds of assets: Tez, tzBTC, and liquidity tokens (LT).
Each of these assets can be sent to LB and received from LB.
To send these assets to LB, the transaction must have the form (where <code>Sender</code> refers to entity sending assets to Dexter):</p>
<ul>
<li>Tez - the <code>Amount</code> argument in a transaction of the form <code>[ Transaction Sender DEXTER Amount _ ]</code></li>
<li>tzBTC - the <code>Tokens</code> argument in a transaction of the form <code>[ Transaction DEXTER TOKEN 0 Transfer(Sender, DEXTER, Tokens) ]</code></li>
<li>LT - the <code>Lt</code> argument in a transaction of the form <code>[ Transaction DEXTER LQT mintOrBurn(Sender, Lt) ]</code> with <code>Lt</code> negative</li>
</ul>
<p>To receive these assets from LB, the transaction must have the form (where <code>Receiver</code> refers to the entity expected to receive assets from Dexter):</p>
<ul>
<li>Tez - the <code>Amount</code> argument in a transaction of the form <code>[ Transaction DEXTER Receiver Amount Default() ]</code></li>
<li>tzBTC - the <code>Tokens</code> argument in a transaction of the form <code>[ Transaction DEXTER TOKEN 0 Transfer(DEXTER, Receiver, Tokens) ]</code></li>
<li>LT - the <code>Lt</code> argument in a transaction of the form <code>[ Transaction DEXTER LQT mintOrBurn(Receiver, Lt) ]</code> with <code>Lt</code> positive</li>
<li>other assets - when using <code>TokenToToken</code>, the <code>MinTokensBought</code> argument in a transaction of the form<br>
<code>[ Transaction DEXTER outputDexterContract _ XtzToToken(Receiver, MinTokensBought, _) ]</code></li>
</ul>
<p>Checking that each entrypoint properly bounds its worst-case exchange rates amounts to checking that:</p>
<ul>
<li>all bounds above are properly applied to all Dexter emitted transactions of the above forms (excepting transactions of the form <code>[ Transaction DEXTER NULL Amount Default() ]</code>, i.e., burned fees).</li>
</ul>
<p>This property immediately follows by our functional correctness specifications.
Note that we must assume that <code>outputDexterContract</code> is, in fact, a valid dexter contract.
Otherwise, its <code>XtzToToken</code> entrypoint may <em>not</em> satisfy the same bounds guarantees that we have listed above.</p>
<h3 id="bounds-on-fees">Bounds on fees</h3>
<p>Note that the calculations in this section discount rouding due to integer division.</p>
<h3 id="tokens-to-xtz">Tokens to XTZ</h3>
<p>When converting from XTZ to Tokens and vice-verca two fees are charges,
the first is sent to the liquity pool increasing the value of each share;
the second is destroyed by sending it to the null address.</p>
<p>Ideally, in a CPMM a user would expect the following exchange rate for selling tokens:</p>
<pre class="language-text"><code>expected_xtz_recieved = (TokensSold * XtzPool)
                        ------------------------
                        (TokensSold + TokenPool)
</code></pre>
<p>However, an amount dependant on the size of the token and xtz pools is kept with
the contract:</p>
<pre class="language-text"><code>currency_bought = (TokensSold * 999 * XtzPool)
                  ---------------------------------------
                  (TokenPool * 1000 + (TokensSold * 999))
</code></pre>
<p>A further 0.1% of this amount is burnt by sending it to the null address, and the user receives:</p>
<pre class="language-text"><code>xtz_recieved = (TokensSold * 999 * XtzPool)          *  999
               -----------------------------------------------------
               (TokensSold * 999 + TokenPool * 1000) * 1000
</code></pre>
<p>The total fee charged is given by this expression:</p>
<pre class="language-text"><code>fee =  (TokensSold * XtzPool)     (TokensSold * 999 * XtzPool)          *  999
       ------------------------ - --------------------------------------------
       (TokensSold + TokenPool)   (TokensSold * 999 + TokenPool * 1000) * 1000
</code></pre>
<p>As fraction of the expected xtz this becomes:</p>
<pre class="language-text"><code>xtz_fee_percent =      (TokensSold * 999 * XtzPool)          *  999       (TokensSold + TokenPool)
                   1 - --------------------------------------------   *   ------------------------
                       (TokensSold * 999 + TokenPool * 1000) * 1000       (TokensSold * XtzPool)

                =      999 * 999 * (TokensSold + TokenPool)
                   1 - --------------------------------------------
                       (TokensSold * 999 + TokenPool * 1000) * 1000
</code></pre>
<p>The fee as a ratio thus depends on the relative values of <code>TokensSold</code> and <code>TokenPool</code>.
When <code>TokensSold == TokenPool</code>, we get the minimum fee of:</p>
<pre class="language-text"><code>min_fee_charged  =      2 * 999 * 999
                     1 - -------------
                         1999 * 1000

                  = 0.00149974987

                 ~= 0.15%
</code></pre>
<p>As the size of the token pool increases, this fee increases asymptotically to:</p>
<pre class="language-text"><code>max  =      999 * 999 * (0 + TokenPool)
        1 - ------------------------------
            ( 0 + TokenPool * 1000) * 1000

     =      999 * 999
        1 - -----------
            1000 * 1000

     = 0.001999

     = 0.1999%
</code></pre>
<h3 id="xtz-to-tokens">XTZ to Tokens</h3>
<p>Similarly, when exchanging tokens for XTZ,
one-thousandth of the amount is burnt before charging a fee:</p>
<pre class="language-text"><code>tokens_received  =  (Amount * 999 / 1000) * 999 * TokenPool
                    -----------------------------------------------
                    (XtzPool * 1000) + (Amount * 999  / 1000) * 999

                 =  999 * 999 * Amount * TokenPool
                    ------------------------------------------
                    XtzPool * 1000 * 1000 + Amount * 999 * 999
</code></pre>
<p>while, in an ideal CPMM a user would expect:</p>
<pre class="language-text"><code>tokens_expected  =  Amount * TokenPool
                    ------------------
                    XtzPool + Amount
</code></pre>
<p>The fee charged is thus:</p>
<pre class="language-text"><code>fee = Amount * TokenPool     999 * 999 * Amount * TokenPool
      ------------------  -  ------------------------------------------
      XtzPool + Amount       XtzPool * 1000 * 1000 + Amount * 999 * 999
</code></pre>
<p>As a percentage, this becomes:</p>
<pre class="language-text"><code>fee =        999 * 999 * Amount * TokenPool               XtzPool + Amount
       1  -  ------------------------------------------ * ------------------
             XtzPool * 1000 * 1000 + Amount * 999 * 999   Amount * TokenPool

    =        999 * 999 * (XtzPool + Amount)
       1  -  ------------------------------------------
             XtzPool * 1000 * 1000 + Amount * 999 * 999
</code></pre>
<p>The fee depends on the ratio of <code>XtzPool</code> to <code>Amount</code>
The fee tends to 0 when the limit of <code>XtzPool</code> is 0 -- i.e. when <code>Amount</code> is large compared to <code>XtzPool</code>.</p>
<pre class="language-text"><code>min_fee_charged =        999 * 999 * Amount
                   1  -  ------------------
                         Amount * 999 * 999

                = 0
</code></pre>
<p>The fee increases as <code>Amount</code> becomes small compared to <code>XtzPool</code> with the limit becoming approximately 0.2% in the limiting case:</p>
<pre class="language-text"><code>max_fee_charged =        999 * 999 * XtzPool
                   1  -  ------------------
                         XtzPool * 1000 * 1000

                =  1  -  0.998001

                =  0.1999 %
</code></pre>
</body></html></div>
        </main>

        <!-- Page ToC -->
        <div class="col-12 col-md-3 col-xl-2 py-md-3 bd-sidebar page-toc mb-3">
          
<div>
<details style="padding:0.25rem 0;;padding-left: 0px;" open>
            <summary class="bd-toc-link-wrapper">
              <a href="#liquidity-baking-safety-property-proofs" class="bd-toc-link">Liquidity Baking Safety Property Proofs</a>
              </summary>
            <div>
              <div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#proof-sketch"
                class="bd-toc-link"
                style="padding-left: 8px;;"
              >
                Proof Sketch
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#notation"
                class="bd-toc-link"
                style="padding-left: 8px;;"
              >
                Notation
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#assumptions-for-tezos-execution-environment"
                class="bd-toc-link"
                style="padding-left: 8px;;"
              >
                Assumptions for Tezos Execution Environment
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#requirements-for-external-contracts"
                class="bd-toc-link"
                style="padding-left: 8px;;"
              >
                Requirements for External Contracts
              </a></div><details style="padding:0.25rem 0;;padding-left: 8px;" open>
            <summary class="bd-toc-link-wrapper">
              <a href="#state-variable-faithfulness" class="bd-toc-link">State Variable Faithfulness</a>
              </summary>
            <div>
              <details style="padding:0.25rem 0;;padding-left: 16px;" open>
            <summary class="bd-toc-link-wrapper">
              <a href="#proof-for-dexter-entrypoint-functions" class="bd-toc-link">Proof for Dexter Entrypoint Functions</a>
              </summary>
            <div>
              <div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#addliquidity"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                AddLiquidity
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#removeliquidity"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                RemoveLiquidity
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#xtztotoken"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                XtzToToken
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#tokentoxtz"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                TokenToXtz
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#tokentotoken"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                TokenToToken
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#default"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                Default
              </a></div>
            </div>
          </details>
        <details style="padding:0.25rem 0;;padding-left: 16px;" open>
            <summary class="bd-toc-link-wrapper">
              <a href="#proof-for-external-contract-calls" class="bd-toc-link">Proof for External Contract Calls</a>
              </summary>
            <div>
              <div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#xtz-transfers"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                XTZ Transfers
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#token-transfers"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                Token Transfers
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#liquidity-mints-and-burns"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                Liquidity Mints and Burns
              </a></div>
            </div>
          </details>
        <details style="padding:0.25rem 0;;padding-left: 16px;" open>
            <summary class="bd-toc-link-wrapper">
              <a href="#abstract-behaviors-of-dexter-entrypoints" class="bd-toc-link">Abstract Behaviors of Dexter Entrypoints</a>
              </summary>
            <div>
              <div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#abstract-configuration"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                Abstract Configuration
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#constants-and-macros"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                Constants and Macros
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#addliquidity-1"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                AddLiquidity
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#removeliquidity-1"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                RemoveLiquidity
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#xtztotoken-1"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                XtzToToken
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#tokentoxtz-1"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                TokenToXtz
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#tokentotoken-1"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                TokenToToken
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#default-1"
                class="bd-toc-link"
                style="padding-left: 24px;;"
              >
                Default
              </a></div>
            </div>
          </details>
        
            </div>
          </details>
        <div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#liquidity-share-value-security"
                class="bd-toc-link"
                style="padding-left: 8px;;"
              >
                Liquidity Share Value Security
              </a></div><details style="padding:0.25rem 0;;padding-left: 8px;" open>
            <summary class="bd-toc-link-wrapper">
              <a href="#operation-safety" class="bd-toc-link">Operation Safety</a>
              </summary>
            <div>
              <div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#bounds-on-fees"
                class="bd-toc-link"
                style="padding-left: 16px;;"
              >
                Bounds on fees
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#tokens-to-xtz"
                class="bd-toc-link"
                style="padding-left: 16px;;"
              >
                Tokens to XTZ
              </a></div><div class="bd-toc-link-wrapper" style="padding:0.25rem 0;">
              <a
                href="#xtz-to-tokens"
                class="bd-toc-link"
                style="padding-left: 16px;;"
              >
                XTZ to Tokens
              </a></div>
            </div>
          </details>
        
            </div>
          </details>
        
</div>

        </div>
        <div class="btn btn-rv-blue page-toc-toggle-btn"></div>
        <!-- End Page ToC -->
      </div>
    </div>
<!-- The footer is now controlled by the k-web-theme git submodule -->
<footer id="rvsite-footer" class="app-footer text-md-left text-center">
  <div class="container">
    <div class="row align-items-center">
      <div class="col-md-4 mb-md-0 mb-4">
        <a href="https://runtimeverification.com/" target="_blank">
          <picture>
            <source
              srcset="
                https://runtimeverification.com/assets/img/rv-logo-dark.png
              "
              media="(prefers-color-scheme: dark)"
            />
            <img
              class="logo-dark"
              src="https://runtimeverification.com/assets/img/rv-logo.png"
              alt="Runtime Verification logo"
              style="height: 32px"
            /> </picture
        ></a>
        <p class="mt-2 text-md-left copyright">
          <a href="https://goo.gl/maps/hKLtCjeEd6yqfzwx5" target="_blank"
            >1807 S Neil Street, Champaign, IL 61820</a
          >
        </p>
      </div>
      <div class="col-md-4 text-md-center mb-md-0 mb-4"></div>
      <div class="col-md-4 mb-md-0 mb-4 text-md-right">
        <p class="copyright">2022 © all rights reserved</p>
      </div>
    </div>
  </div>
</footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Typist/1.2/typist.min.js"></script>
    <script src="../../../../assets/js/index.js"></script>
  </body>
</html>
