

       {Invariant /\ C } Body { Invariant } 
---------------------------------------------------------
{Invariant}    while (C) { Body }       {Invariant /\ !C}




-----------------------------------------------------------
{! EG } if (EG) { do { Body } while(CG) }           { !EG }


       {Invariant /\ C } Body { Invariant } 
-----------------------------------------------------------
{ EG } if (EG) { do { Body } while(CG) }           { Invariant and !CG }


(1) if (EG) { (2) Body ; (3) while(CG) { Body } }






< (bool T) : (EG S) /\ Pre > LOOP { Body } < T : S' /\ Invariant /\ (!CG \/ !EG) >









< (bool T) : (EG S) /\ Pre > LOOP { Body } < T : S' /\ Post >






1. assert(Invariant) 
   if (EG) {
       Body ;
       assert(Invariant)
       while(CG) {
         Body
         assert(Invariant)
       }
   }
   //    Invaraint /\ !CG
   // || Invariant /\ !EG
   Remaining

    //  Shape of the invariant can include bool at top of stack
    1.  Pre => Invariant
    2.  < T : S /\ Pre /\ Invariant /\ EG > Body < (bool T) : (B S) /\ Invariant >  
    3.  < T : S        /\ Invariant /\ CG > Body < (bool T) : (B S) /\ Invariant >
    ------------------------------------------------------------------------------
    < (bool T) : (EG S) /\ Pre > LOOP { Body } < T : S' /\ Invariant /\ (!CG \/ !EG) >

    CG === ??? inside < T : S /\ ??? > Body < (bool T) : True S' >

    rule <k> LOOP A .AnnotationList Body
          => /* (1) */ 
             BIND { Shape } { ASSERT Predicates } ;
             LOOP .AnnotationList {
               Body
               BIND { Shape } { ASSERT Predicates } ;
               /* (2) */
               CUTPOINT(!Int, Shape) ;
               BIND { Shape } { ASSUME Predicates } ;
               /* (3) */
            }
            /* (4) */

            // (1)     // Pre => Invariant
            // (1, 2)  // < Pre /\ EG > Body < Invariant >
            // (3, 2)  // < Invariant /\ ??? >li 

1'. if (EG) {
       assert(Invariant) 
       Body ;
       while(CG) {
         assert(Invariant);
         Body
       }
   }
   assert(Invariant)
   //    Invaraint /\ !CG
   // || Invariant /\ !EG


    //  Shape of the invariant does not include bool at top of stack
    1.  Pre /\ EG => Invariant
    2.  < T : S /\ Pre /\ Invariant /\ EG > Body < (bool T) : (B S) /\ Invariant >  
    3.  < T : S        /\ Invariant /\ CG > Body < (bool T) : (B S) /\ Invariant >
    ------------------------------------------------------------------------------
    < (bool T) : (EG S) /\ Pre > LOOP { Body } < T : S' /\ Invariant /\ (!CG \/ !EG) >

    rule <k> LOOP A .AnnotationList Body
          => /* (1) */
             LOOP .AnnotationList {
               /* (2) */
               BIND { Shape } { ASSERT Predicates } ;   // (1, 2) < Pre /\ EG > noop < Invariant >
               // Body
               // BIND { Shape } { ASSERT Predicates } ;
               //
               CUTPOINT(!Int, Shape) ;
               BIND { Shape } { ASSUME Predicates } ;   // (3, 2) < Invariant /\  CG > Body < Invariant >
               /* (3) */
               Body                                     
             }
             /* (4) */
             BIND { Shape } { ASSERT Predicates } ;     // (1, 4) Pre /\ !EG => Inv
                                                        // (3, 4) < Invariant /\ !CG > Body < Invariant >
             ...                                        // (1, 4, ...) (3, 4, ...) < (Pre /\ !EG)  || (Invariant /\ ! CG) >

2. if (EG) {
       assert(Invariant) 
       Body ;
       while(CG) {
         assert(Invariant);
         Body
       }
       assert(Invariant)
   }
   // !EG || (Invaraint /\ !CG)
   Remaining

    <Invariant /\ EG> Body <Invariant>          <Invariant /\ CG> Body <Invariant>
    -------------------------------------------------------------------------------
             LOOP { Body }     <!EG || Invariant /\ !CG> 

    And then prove:
    * <!EG>              Remaining <Post>
    * <Invariant /\ !CG> Remaining <Post>

3. if (EG) {
       Body ;
       assert(Invariant)
       while(CG) {
         Body
         assert(Invariant)
       }
   }
