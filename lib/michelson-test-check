#!/usr/bin/env python3

# Usage: ./kmich run ... --search-final --output json | $0 <path-to-definition>
#
# Reads kmichelson json output for unit-tests and checks that all branches have succeeded.
# Exits 127 if there is a stuck term. Otherwise, exits with the number of failing branches

import json
import os
import pyk
import sys

def findSubtermsByLabel(label, term):
    if not (pyk.isKSequence(term) or pyk.isKApply(term)): return []
    if pyk.isKApply(term):
        if term['label'] == label: return [term]
        ret = []
        for subterm in term['args']:
            ret += findSubtermsByLabel(label, subterm)
        return ret
    return []

def findImmediateSubtermsByLabel(labels,term):
    if not pyk.isKApply(term): return dict()
    ret = dict()
    for label in labels:
        for subterm in term['args']:
            if subterm['label'] == label:
                ret[label] = subterm
                break
        if not label in ret.keys(): raise ValueError("Subterm " + label + " not found")
    return ret

def parseKastTerm(jsonString):
    return json.loads(jsonString)['term']

def findFailingBranches(term):
    success_count = 0
    failures = []
    stucks = []
    for branchTop in findSubtermsByLabel('#And', term):

        constraints = filter(lambda x: findSubtermsByLabel('<michelsonTop>',x) == [], findSubtermsByLabel('#Equals', branchTop))

        topCells = findSubtermsByLabel('<michelsonTop>', branchTop)
        assert(len(topCells) == 1)
        topCell = topCells[0]

        cells = findImmediateSubtermsByLabel(['<k>','<stack>','<symbols>'], topCell)

        assert(cells['<k>']['arity'] == 1)
        kcell = cells['<k>']['args'][0]
        assert(pyk.isKSequence(kcell))

        if   kcell['items'] == []:                          success_count += 1
        elif kcell['items'][0]['label'] != '#AssertFailed': stucks += [(constraints,cells)]
        else:                                               failures += [(constraints,cells)]
    return success_count, failures, stucks

def printStates(statetype,states):
    if len(states) == 0: return
    print(statetype + "s:")
    for i,(constraints,state) in enumerate(states):
        statenum = " " + statetype + ": " + str(i)
        print(">" * abs(80 - len(statenum)) + statenum)
        for constraint in constraints: print("  " + pyk.prettyPrintKast(constraint, symbolTable))
        for name, term in state.items():
            print(pyk.prettyPrintKast(term, symbolTable))
    print()
    sys.stdout.flush()

assert(len(sys.argv) == 2)
pathToDefinition = sys.argv[1]
definition = pyk.readKastTerm(os.path.join(pathToDefinition, 'compiled.json'))
symbolTable = pyk.buildSymbolTable(definition)
outputTerm = parseKastTerm(sys.stdin.read())
success_count, failures, stucks = findFailingBranches(outputTerm)
printStates("Stuck",stucks)
printStates("Failure",failures)

print("%d branches succeeded; %d branches failed; %d branches stuck." % (success_count, len(failures), len(stucks)))
if len(stucks) != 0: sys.exit(127)
sys.exit(min(len(failures), 126))
