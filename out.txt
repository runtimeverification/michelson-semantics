    {
      ?V0 >=Int 0
    #Equals
      true
    }
  #And
    {
      ?V <Int ?V0
    #Equals
      false
    }
  #And
    {
      ?V >=Int 0
    #Equals
      true
    }
  #And
    {
      Result
    #Equals
      <generatedTop>
        <michelsonTop>
          <k>
            .
          </k>
          <stack>
            .
          </stack>
          <stacktypes>
            .TypeSeq
          </stacktypes>
          <paramtype>
            #NotSet
          </paramtype>
          <paramvalue>
            #NoData
          </paramvalue>
          <storagetype>
            #NotSet
          </storagetype>
          <storagevalue>
            #NoData
          </storagevalue>
          <mybalance>
            #Mutez ( 0 )
          </mybalance>
          <myamount>
            #Mutez ( 0 )
          </myamount>
          <mynow>
            #Timestamp ( 0 )
          </mynow>
          <myaddr>
            #Address ( "InvalidMyAddr" )
          </myaddr>
          <knownaddrs>
            .Map
          </knownaddrs>
          <sourceaddr>
            #Address ( "InvalidSourceAddr" )
          </sourceaddr>
          <senderaddr>
            #Address ( "InvalidSenderAddr" )
          </senderaddr>
          <mychainid>
            #ChainId ( 0x )
          </mychainid>
          <nonce>
            #Nonce ( 0 )
          </nonce>
          <bigmaps>
            .Map
          </bigmaps>
          <returncode>
            0
          </returncode>
        </michelsonTop>
        <symbolsLoaded>
          true
        </symbolsLoaded>
        <symbols>
          $I1 |-> #TypedSymbol ( nat .AnnotationList , ?V:Int )
          $I2 |-> #TypedSymbol ( nat .AnnotationList , ?V0:Int )
        </symbols>
        <preconditions>
          .List
        </preconditions>
        <postconditions>
          .List
        </postconditions>
        <invariants>
          .Map
        </invariants>
        <assumeFailed>
          true
        </assumeFailed>
      </generatedTop>
    }
#Or
    {
      ?V0 >=Int 0
    #Equals
      true
    }
  #And
    {
      ?V <Int ?V0
    #Equals
      true
    }
  #And
    {
      ?V >=Int 0
    #Equals
      true
    }
  #And
    {
      Result
    #Equals
      <generatedTop>
        <michelsonTop>
          <k>
            #AssumeInvariant ( @I ) ~> { PUSH .AnnotationList nat .AnnotationList 1 ; ADD .AnnotationList ; DUP .AnnotationList ; DIG .AnnotationList 2 ; DUP .AnnotationList ; DUG .AnnotationList 3 ; SWAP .AnnotationList ; COMPARE .AnnotationList ; LT .AnnotationList } ~> #RecordHaltCondition ~> #AssertInvariant ( @I ) ~> #AssumeHaltCondition ~> #AssumeInvariant ( @I ) ~> DIP .AnnotationList { DROP .AnnotationList } ~> #LoadGroups ( Binder { Stack_elt nat .AnnotationList $I3 } ; postcondition { { PUSH .AnnotationList nat .AnnotationList $I2 ; PUSH .AnnotationList nat .AnnotationList $I3 ; COMPARE .AnnotationList ; EQ .AnnotationList } } )
          </k>
          <stack>
            ?V:Int ~> ?V0:Int
          </stack>
          <stacktypes>
            nat .AnnotationList ; nat .AnnotationList ; .TypeSeq
          </stacktypes>
          <paramtype>
            #NotSet
          </paramtype>
          <paramvalue>
            #NoData
          </paramvalue>
          <storagetype>
            #NotSet
          </storagetype>
          <storagevalue>
            #NoData
          </storagevalue>
          <mybalance>
            #Mutez ( 0 )
          </mybalance>
          <myamount>
            #Mutez ( 0 )
          </myamount>
          <mynow>
            #Timestamp ( 0 )
          </mynow>
          <myaddr>
            #Address ( "InvalidMyAddr" )
          </myaddr>
          <knownaddrs>
            .Map
          </knownaddrs>
          <sourceaddr>
            #Address ( "InvalidSourceAddr" )
          </sourceaddr>
          <senderaddr>
            #Address ( "InvalidSenderAddr" )
          </senderaddr>
          <mychainid>
            #ChainId ( 0x )
          </mychainid>
          <nonce>
            #Nonce ( 0 )
          </nonce>
          <bigmaps>
            .Map
          </bigmaps>
          <returncode>
            1
          </returncode>
        </michelsonTop>
        <symbolsLoaded>
          true
        </symbolsLoaded>
        <symbols>
          $I1 |-> #TypedSymbol ( nat .AnnotationList , ?V:Int )
          $I2 |-> #TypedSymbol ( nat .AnnotationList , ?V0:Int )
        </symbols>
        <preconditions>
          .List
        </preconditions>
        <postconditions>
          .List
        </postconditions>
        <invariants>
          @I |-> { { PUSH .AnnotationList bool .AnnotationList true } }
        </invariants>
        <assumeFailed>
          false
        </assumeFailed>
      </generatedTop>
    }
